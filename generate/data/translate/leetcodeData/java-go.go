func maxPower(s string) int { ans, cnt := 1, 1 for i := 1; i < len(s); i++ { if s[i] == s[i-1] { cnt++ if cnt > ans { ans = cnt } } else { cnt = 1 } } return ans }
func findNthDigit(n int) int { d := 1 for count := 9; n > d*count; count *= 10 { n -= d * count d++ } index := n - 1 start := int(math.Pow10(d - 1)) num := start + index/d digitIndex := index % d return num / int(math.Pow10(d-digitIndex-1)) % 10 }
func kthSmallestPrimeFraction(arr []int, k int) []int { n := len(arr) left, right := 0., 1. for { mid := (left + right) / 2 i, count := -1, 0 x, y := 0, 1 for j := 1; j < n; j++ { for float64(arr[i+1])/float64(arr[j]) < mid { i++ if arr[i]*y > arr[j]*x { x, y = arr[i], arr[j] } } count += i + 1 } if count == k { return []int{x, y} } if count < k { left = mid } else { right = mid } } }
func findAnagrams(s, p string) (ans []int) { sLen, pLen := len(s), len(p) if sLen < pLen { return } var sCount, pCount [26]int for i, ch := range p { sCount[s[i]-'a']++ pCount[ch-'a']++ } if sCount == pCount { ans = append(ans, 0) } for i, ch := range s[:sLen-pLen] { sCount[ch-'a']-- sCount[s[i+pLen]-'a']++ if sCount == pCount { ans = append(ans, i+1) } } return }
func (s *Solution) Flip() []int { x := rand.Intn(s.total) s.total-- sumZero, curr := 0, 0 for _, bucket := range s.buckets { if sumZero+s.bucketSize-len(bucket) > x { for i := 0; i < s.bucketSize; i++ { if !bucket[curr+i] { if sumZero == x { bucket[curr+i] = true return []int{(curr + i) / s.n, (curr + i) % s.n} } sumZero++ } } } curr += s.bucketSize sumZero += s.bucketSize - len(bucket) } return nil }
func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if val == root.Val { return root } if val < root.Val { return searchBST(root.Left, val) } return searchBST(root.Right, val) }
func poorPigs(buckets, minutesToDie, minutesToTest int) int { states := minutesToTest/minutesToDie + 1 return int(math.Ceil(math.Log(float64(buckets)) / math.Log(float64(states)))) }
func (s *Solution) Shuffle() []int { n := len(s.nums) for i := range s.nums { j := i + rand.Intn(n-i) s.nums[i], s.nums[j] = s.nums[j], s.nums[i] } return s.nums }
func maxDepth(root *Node) int { if root == nil { return 0 } maxChildDepth := 0 for _, child := range root.Children { if childDepth := maxDepth(child); childDepth > maxChildDepth { maxChildDepth = childDepth } } return maxChildDepth + 1 }
func findLHS(nums []int) (ans int) { sort.Ints(nums) begin := 0 for end, num := range nums { for num-nums[begin] > 1 { begin++ } if num-nums[begin] == 1 && end-begin+1 > ans { ans = end - begin + 1 } } return }
func integerReplacement(n int) int { if n == 1 { return 0 } if n%2 == 0 { return 1 + integerReplacement(n/2) } return 2 + min(integerReplacement(n/2), integerReplacement(n/2+1)) }
func maxProduct(words []string) (ans int) { masks := make([]int, len(words)) for i, word := range words { for _, ch := range word { masks[i] |= 1 << (ch - 'a') } } for i, x := range masks { for j, y := range masks[:i] { if x&y == 0 && len(words[i])*len(words[j]) > ans { ans = len(words[i]) * len(words[j]) } } } return }
func bulbSwitch(n int) int { return int(math.Sqrt(float64(n) + 0.5)) }
func (m *MapSum) Insert(key string, val int) { delta := val if m.cnt[key] > 0 { delta -= m.cnt[key] } m.cnt[key] = val node := m.root for _, ch := range key { ch -= 'a' if node.children[ch] == nil { node.children[ch] = &TrieNode{} } node = node.children[ch] node.val += delta } }
func detectCapitalUse(word string) bool { if len(word) >= 2 && unicode.IsLower(rune(word[0])) && unicode.IsUpper(rune(word[1])) { return false } for i := 2; i < len(word); i++ { if unicode.IsLower(rune(word[i])) != unicode.IsLower(rune(word[1])) { return false } } return true }
func getMoneyAmount(n int) int { f := make([][]int, n+1) for i := range f { f[i] = make([]int, n+1) } for i := n - 1; i >= 1; i-- { for j := i + 1; j <= n; j++ { f[i][j] = j + f[i][j-1] for k := i; k < j; k++ { cost := k + max(f[i][k-1], f[k+1][j]) if cost < f[i][j] { f[i][j] = cost } } } } return f[1][n] }
func findPoisonedDuration(timeSeries []int, duration int) (ans int) { expired := 0 for _, t := range timeSeries { if t >= expired { ans += duration } else { ans += t + duration - expired } expired = t + duration } return }
func buddyStrings(s, goal string) bool { if len(s) != len(goal) { return false } if s == goal { seen := [26]bool{} for _, ch := range s { if seen[ch-'a'] { return true } seen[ch-'a'] = true } return false } first, second := -1, -1 for i := range s { if s[i] != goal[i] { if first == -1 { first = i } else if second == -1 { second = i } else { return false } } } return second != -1 && s[first] == goal[second] && s[second] == goal[first] }
func getHint(secret, guess string) string { bulls := 0 var cntS, cntG [10]int for i := range secret { if secret[i] == guess[i] { bulls++ } else { cntS[secret[i]-'0']++ cntG[guess[i]-'0']++ } } cows := 0 for i := 0; i < 10; i++ { cows += min(cntS[i], cntG[i]) } return fmt.Sprintf("%dA%dB", bulls, cows) }
func maxCount(m, n int, ops [][]int) int { mina, minb := m, n for _, op := range ops { mina = min(mina, op[0]) minb = min(minb, op[1]) } return mina * minb }
func missingNumber(nums []int) int { sort.Ints(nums) for i, num := range nums { if num != i { return i } } return len(nums) }
func longestSubsequence(arr []int, difference int) (ans int) { dp := map[int]int{} for _, v := range arr { dp[v] = dp[v-difference] + 1 if dp[v] > ans { ans = dp[v] } } return }
func isPerfectSquare(num int) bool { x := int(math.Sqrt(float64(num))) return x*x == num }
func deleteNode(node *ListNode) { node.Val = node.Next.Val node.Next = node.Next.Next }
func removeInvalidParentheses(s string) (ans []string) { curSet := map[string]struct{}{s: {}} for { for str := range curSet { if isValid(str) { ans = append(ans, str) } } if len(ans) > 0 { return } nextSet := map[string]struct{}{} for str := range curSet { for i, ch := range str { if i > 0 && byte(ch) == str[i-1] { continue } if ch == '(' || ch == ')' { nextSet[str[:i]+str[i+1:]] = struct{}{} } } } curSet = nextSet } }
func nextGreaterElement(nums1, nums2 []int) []int { mp := map[int]int{} stack := []int{} for i := len(nums2) - 1; i >= 0; i-- { num := nums2[i] for len(stack) > 0 && num >= stack[len(stack)-1] { stack = stack[:len(stack)-1] } if len(stack) > 0 { mp[num] = stack[len(stack)-1] } else { mp[num] = -1 } stack = append(stack, num) } res := make([]int, len(nums1)) for i, num := range nums1 { res[i] = mp[num] } return res }
func searchMatrix(matrix [][]int, target int) bool { for _, row := range matrix { for _, v := range row { if v == target { return true } } } return false }
func constructRectangle(area int) []int { w := int(math.Sqrt(float64(area))) for area%w > 0 { w-- } return []int{area / w, w} }
func plusOne(digits []int) []int { n := len(digits) for i := n - 1; i >= 0; i-- { if digits[i] != 9 { digits[i]++ for j := i + 1; j < n; j++ { digits[j] = 0 } return digits } } digits = make([]int, n+1) digits[0] = 1 return digits }
func minMoves(nums []int) (ans int) { min := nums[0] for _, num := range nums[1:] { if num < min { min = num } } for _, num := range nums { ans += num - min } return }
func findComplement(num int) int { highBit := 0 for i := 1; i <= 30; i++ { if num < 1<<i { break } highBit = i } mask := 1<<(highBit+1) - 1 return num ^ mask }
func bitwiseComplement(n int) int { highBit := 0 for i := 1; i <= 30; i++ { if n < 1<<i { break } highBit = i } mask := 1<<(highBit+1) - 1 return n ^ mask }
func kthSmallest(root *TreeNode, k int) int { stack := []*TreeNode{} for { for root != nil { stack = append(stack, root) root = root.Left } stack, root = stack[:len(stack)-1], stack[len(stack)-1] k-- if k == 0 { return root.Val } root = root.Right } }
func countAndSay(n int) string { prev := "1" for i := 2; i <= n; i++ { cur := &strings.Builder{} for j, start := 0, 0; j < len(prev); start = j { for j < len(prev) && prev[j] == prev[start] { j++ } cur.WriteString(strconv.Itoa(j - start)) cur.WriteByte(prev[start]) } prev = cur.String() } return prev }
func fizzBuzz(n int) (ans []string) { for i := 1; i <= n; i++ { sb := &strings.Builder{} if i%3 == 0 { sb.WriteString("Fizz") } if i%5 == 0 { sb.WriteString("Buzz") } if sb.Len() == 0 { sb.WriteString(strconv.Itoa(i)) } ans = append(ans, sb.String()) } return }
func arrangeCoins(n int) int { return int((math.Sqrt(float64(8*n+1)) - 1) / 2) }
func findRepeatedDnaSequences(s string) (ans []string) { cnt := map[string]int{} for i := 0; i <= len(s)-L; i++ { sub := s[i : i+L] cnt[sub]++ if cnt[sub] == 2 { ans = append(ans, sub) } } return }
func countSegments(s string) (ans int) { for i, ch := range s { if (i == 0 || s[i-1] == ' ') && ch != ' ' { ans++ } } return }
func thirdMax(nums []int) int { a, b, c := math.MinInt64, math.MinInt64, math.MinInt64 for _, num := range nums { if num > a { a, b, c = num, a, b } else if a > num && num > b { b, c = num, b } else if b > num && num > c { c = num } } if c == math.MinInt64 { return a } return c }
func toHex(num int) string { if num == 0 { return "0" } sb := &strings.Builder{} for i := 7; i >= 0; i-- { val := num >> (4 * i) & 0xf if val > 0 || sb.Len() > 0 { var digit byte if val < 10 { digit = '0' + byte(val) } else { digit = 'a' + byte(val-10) } sb.WriteByte(digit) } } return sb.String() }
func destCity(paths [][]string) string { citiesA := map[string]bool{} for _, path := range paths { citiesA[path[0]] = true } for _, path := range paths { if !citiesA[path[1]] { return path[1] } } return "" }
func computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 int) int { area1 := (ax2 - ax1) * (ay2 - ay1) area2 := (bx2 - bx1) * (by2 - by1) overlapWidth := min(ax2, bx2) - max(ax1, bx1) overlapHeight := min(ay2, by2) - max(ay1, by1) overlapArea := max(overlapWidth, 0) * max(overlapHeight, 0) return area1 + area2 - overlapArea }
func findMinMoves(machines []int) (ans int) { tot := 0 for _, v := range machines { tot += v } n := len(machines) if tot%n > 0 { return -1 } avg := tot / n sum := 0 for _, num := range machines { num -= avg sum += num ans = max(ans, max(abs(sum), num)) } return }
func pathSum(root *TreeNode, targetSum int) int { if root == nil { return 0 } res := rootSum(root, targetSum) res += pathSum(root.Left, targetSum) res += pathSum(root.Right, targetSum) return res }
func getSum(a, b int) int { for b != 0 { carry := uint(a&b) << 1 a ^= b b = int(carry) } return a }
func minDistance(word1, word2 string) int { m, n := len(word1), len(word2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i, c1 := range word1 { for j, c2 := range word2 { if c1 == c2 { dp[i+1][j+1] = dp[i][j] + 1 } else { dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) } } } lcs := dp[m][n] return m + n - lcs*2 }
func dfs(node *Node) (last *Node) { cur := node for cur != nil { next := cur.Next if cur.Child != nil { childLast := dfs(cur.Child) next = cur.Next cur.Next = cur.Child cur.Child.Prev = cur if next != nil { childLast.Next = next next.Prev = childLast } cur.Child = nil last = childLast } else { last = cur } cur = next } return }
func isPowerOfThree(n int) bool { for n > 0 && n%3 == 0 { n /= 3 } return n == 1 }
func splitListToParts(head *ListNode, k int) []*ListNode { n := 0 for node := head; node != nil; node = node.Next { n++ } quotient, remainder := n/k, n%k parts := make([]*ListNode, k) for i, curr := 0, head; i < k && curr != nil; i++ { parts[i] = curr partSize := quotient if i < remainder { partSize++ } for j := 1; j < partSize; j++ { curr = curr.Next } curr, curr.Next = curr.Next, nil } return parts }
func lengthOfLastWord(s string) (ans int) { index := len(s) - 1 for s[index] == ' ' { index-- } for index >= 0 && s[index] != ' ' { ans++ index-- } return }
func findNumberOfLIS(nums []int) (ans int) { maxLen := 0 n := len(nums) dp := make([]int, n) cnt := make([]int, n) for i, x := range nums { dp[i] = 1 cnt[i] = 1 for j, y := range nums[:i] { if x > y { if dp[j]+1 > dp[i] { dp[i] = dp[j] + 1 cnt[i] = cnt[j] } else if dp[j]+1 == dp[i] { cnt[i] += cnt[j] } } } if dp[i] > maxLen { maxLen = dp[i] ans = cnt[i] } else if dp[i] == maxLen { ans += cnt[i] } } return }
func minSteps(n int) int { f := make([]int, n+1) for i := 2; i <= n; i++ { f[i] = math.MaxInt32 for j := 1; j*j <= i; j++ { if i%j == 0 { f[i] = min(f[i], f[j]+i/j) f[i] = min(f[i], f[i/j]+j) } } } return f[n] }
func canWinNim(n int) bool { return n%4 != 0 }
func isValidSudoku(board [][]byte) bool { var rows, columns [9][9]int var subboxes [3][3][9]int for i, row := range board { for j, c := range row { if c == '.' { continue } index := c - '1' rows[i][index]++ columns[j][index]++ subboxes[i/3][j/3][index]++ if rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i/3][j/3][index] > 1 { return false } } } return true }
func findPeakElement(nums []int) (idx int) { for i, v := range nums { if v > nums[idx] { idx = i } } return }
func numberOfBoomerangs(points [][]int) (ans int) { for _, p := range points { cnt := map[int]int{} for _, q := range points { dis := (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1]) cnt[dis]++ } for _, m := range cnt { ans += m * (m - 1) } } return }
func checkValidString(s string) bool { minCount, maxCount := 0, 0 for _, ch := range s { if ch == '(' { minCount++ maxCount++ } else if ch == ')' { minCount = max(minCount-1, 0) maxCount-- if maxCount < 0 { return false } } else { minCount = max(minCount-1, 0) maxCount++ } } return minCount == 0 }
func findIntegers(n int) (ans int) { dp := [31]int{1, 1} for i := 2; i < 31; i++ { dp[i] = dp[i-1] + dp[i-2] } for i, pre := 29, 0; i >= 0; i-- { val := 1 << i if n&val > 0 { ans += dp[i+1] if pre == 1 { break } pre = 1 } else { pre = 0 } if i == 0 { ans++ } } return }
func search(nums []int, target int) int { low, high := 0, len(nums)-1 for low <= high { mid := (high-low)/2 + low num := nums[mid] if num == target { return mid } else if num > target { high = mid - 1 } else { low = mid + 1 } } return -1 }
func rand10() int { for { row := rand7() col := rand7() idx := (row-1)*7 + col if idx <= 40 { return 1 + (idx-1)%10 } } }
func compareVersion(version1, version2 string) int { v1 := strings.Split(version1, ".") v2 := strings.Split(version2, ".") for i := 0; i < len(v1) || i < len(v2); i++ { x, y := 0, 0 if i < len(v1) { x, _ = strconv.Atoi(v1[i]) } if i < len(v2) { y, _ = strconv.Atoi(v2[i]) } if x > y { return 1 } if x < y { return -1 } } return 0 }
func corpFlightBookings(bookings [][]int, n int) []int { nums := make([]int, n) for _, booking := range bookings { nums[booking[0]-1] += booking[2] if booking[1] < n { nums[booking[1]] -= booking[2] } } for i := 1; i < n; i++ { nums[i] += nums[i-1] } return nums }
func sumOddLengthSubarrays(arr []int) (sum int) { n := len(arr) for start := range arr { for length := 1; start+length <= n; length += 2 { for _, v := range arr[start : start+length] { sum += v } } } return sum }
func balancedStringSplit(s string) (ans int) { d := 0 for _, ch := range s { if ch == 'L' { d++ } else { d-- } if d == 0 { ans++ } } return }
func runningSum(nums []int) []int { n := len(nums) for i := 1; i < n; i++ { nums[i] += nums[i-1] } return nums }
func (mf *MedianFinder) AddNum(num int) { minQ, maxQ := &mf.queMin, &mf.queMax if minQ.Len() == 0 || num <= -minQ.IntSlice[0] { heap.Push(minQ, -num) if maxQ.Len()+1 < minQ.Len() { heap.Push(maxQ, -heap.Pop(minQ).(int)) } } else { heap.Push(maxQ, num) if maxQ.Len() > minQ.Len() { heap.Push(minQ, -heap.Pop(maxQ).(int)) } } }
func numRescueBoats(people []int, limit int) (ans int) { sort.Ints(people) light, heavy := 0, len(people)-1 for light <= heavy { if people[light]+people[heavy] > limit { heavy-- } else { light++ heavy-- } ans++ } return }
func findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int { const inf = 10000*101 + 1 f := make([]int, n) for i := range f { f[i] = inf } f[src] = 0 ans := inf for t := 1; t <= k+1; t++ { g := make([]int, n) for i := range g { g[i] = inf } for _, flight := range flights { j, i, cost := flight[0], flight[1], flight[2] g[i] = min(g[i], f[j]+cost) } f = g ans = min(ans, f[dst]) } if ans == inf { ans = -1 } return ans }
func getMaximumGenerated(n int) (ans int) { if n == 0 { return } nums := make([]int, n+1) nums[1] = 1 for i := 2; i <= n; i++ { nums[i] = nums[i/2] + i%2*nums[i/2+1] } for _, v := range nums { ans = max(ans, v) } return }
func escapeGhosts(ghosts [][]int, target []int) bool { source := []int{0, 0} distance := manhattanDistance(source, target) for _, ghost := range ghosts { if manhattanDistance(ghost, target) <= distance { return false } } return true }
func compress(chars []byte) int { write, left := 0, 0 for read, ch := range chars { if read == len(chars)-1 || ch != chars[read+1] { chars[write] = ch write++ num := read - left + 1 if num > 1 { anchor := write for ; num > 0; num /= 10 { chars[write] = '0' + byte(num%10) write++ } s := chars[anchor:write] for i, n := 0, len(s); i < n/2; i++ { s[i], s[n-1-i] = s[n-1-i], s[i] } } left = read + 1 } } return write }
func reverseStr(s string, k int) string { t := []byte(s) for i := 0; i < len(s); i += 2 * k { sub := t[i:min(i+k, len(s))] for j, n := 0, len(sub); j < n/2; j++ { sub[j], sub[n-1-j] = sub[n-1-j], sub[j] } } return string(t) }
func reverseVowels(s string) string { t := []byte(s) n := len(t) i, j := 0, n-1 for i < j { for i < n && !strings.Contains("aeiouAEIOU", string(t[i])) { i++ } for j > 0 && !strings.Contains("aeiouAEIOU", string(t[j])) { j-- } if i < j { t[i], t[j] = t[j], t[i] i++ j-- } } return string(t) }
func checkRecord(n int) (ans int) { const mod int = 1e9 + 7 dp := make([][2][3]int, n+1) dp[0][0][0] = 1 for i := 1; i <= n; i++ { for j := 0; j <= 1; j++ { for k := 0; k <= 2; k++ { dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % mod } } for k := 0; k <= 2; k++ { dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][k]) % mod } for j := 0; j <= 1; j++ { for k := 1; k <= 2; k++ { dp[i][j][k] = (dp[i][j][k] + dp[i-1][j][k-1]) % mod } } } for j := 0; j <= 1; j++ { for k := 0; k <= 2; k++ { ans = (ans + dp[n][j][k]) % mod } } return ans }
func checkRecord(s string) bool { absents, lates := 0, 0 for _, ch := range s { if ch == 'A' { absents++ if absents >= 2 { return false } } if ch == 'L' { lates++ if lates >= 3 { return false } } else { lates = 0 } } return true }
func countArrangement(n int) int { f := make([]int, 1<<n) f[0] = 1 for mask := 1; mask < 1<<n; mask++ { num := bits.OnesCount(uint(mask)) for i := 0; i < n; i++ { if mask>>i&1 > 0 && (num%(i+1) == 0 || (i+1)%num == 0) { f[mask] += f[mask^1<<i] } } } return f[1<<n-1] }
func findPaths(m, n, maxMove, startRow, startColumn int) (ans int) { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) } dp[startRow][startColumn] = 1 for i := 0; i < maxMove; i++ { dpNew := make([][]int, m) for j := range dpNew { dpNew[j] = make([]int, n) } for j := 0; j < m; j++ { for k := 0; k < n; k++ { count := dp[j][k] if count > 0 { for _, dir := range dirs { j1, k1 := j+dir.x, k+dir.y if j1 >= 0 && j1 < m && k1 >= 0 && k1 < n { dpNew[j1][k1] = (dpNew[j1][k1] + count) % mod } else { ans = (ans + count) % mod } } } } } dp = dpNew } return }
func countDigitOne(n int) (ans int) { for k, mulk := 0, 1; n >= mulk; k++ { ans += (n/(mulk*10))*mulk + min(max(n%(mulk*10)-mulk+1, 0), mulk) mulk *= 10 } return }
func longestPalindromeSubseq(s string) int { n := len(s) dp := make([][]int, n) for i := range dp { dp[i] = make([]int, n) } for i := n - 1; i >= 0; i-- { dp[i][i] = 1 for j := i + 1; j < n; j++ { if s[i] == s[j] { dp[i][j] = dp[i+1][j-1] + 2 } else { dp[i][j] = max(dp[i+1][j], dp[i][j-1]) } } } return dp[0][n-1] }
func nthSuperUglyNumber(n int, primes []int) int { dp := make([]int, n+1) m := len(primes) pointers := make([]int, m) nums := make([]int, m) for i := range nums { nums[i] = 1 } for i := 1; i <= n; i++ { minNum := math.MaxInt64 for j := range pointers { minNum = min(minNum, nums[j]) } dp[i] = minNum for j := range nums { if nums[j] == minNum { pointers[j]++ nums[j] = dp[pointers[j]] * primes[j] } } } return dp[n] }
func tribonacci(n int) int { if n == 0 { return 0 } if n <= 2 { return 1 } p, q, r, s := 0, 0, 1, 1 for i := 3; i <= n; i++ { p = q q = r r = s s = p + q + r } return s }
func shortestPathLength(graph [][]int) int { n := len(graph) type tuple struct{ u, mask, dist int } q := []tuple{} seen := make([][]bool, n) for i := range seen { seen[i] = make([]bool, 1<<n) seen[i][1<<i] = true q = append(q, tuple{i, 1 << i, 0}) } for { t := q[0] q = q[1:] if t.mask == 1<<n-1 { return t.dist } for _, v := range graph[t.u] { maskV := t.mask | 1<<v if !seen[v][maskV] { q = append(q, tuple{v, maskV, t.dist + 1}) seen[v][maskV] = true } } } }
func triangleNumber(nums []int) (ans int) { n := len(nums) sort.Ints(nums) for i, v := range nums { k := i for j := i + 1; j < n; j++ { for k+1 < n && nums[k+1] < v+nums[j] { k++ } ans += max(k-j, 0) } } return }
func findUnsortedSubarray(nums []int) int { if sort.IntsAreSorted(nums) { return 0 } numsSorted := append([]int(nil), nums...) sort.Ints(numsSorted) left, right := 0, len(nums)-1 for nums[left] == numsSorted[left] { left++ } for nums[right] == numsSorted[right] { right-- } return right - left + 1 }
func pathInZigZagTree(label int) (path []int) { row, rowStart := 1, 1 for rowStart*2 <= label { row++ rowStart *= 2 } if row%2 == 0 { label = getReverse(label, row) } for row > 0 { if row%2 == 0 { path = append(path, getReverse(label, row)) } else { path = append(path, label) } row-- label >>= 1 } for i, n := 0, len(path); i < n/2; i++ { path[i], path[n-1-i] = path[n-1-i], path[i] } return }
func minOperations(target, arr []int) int { n := len(target) pos := make(map[int]int, n) for i, val := range target { pos[val] = i } d := []int{} for _, val := range arr { if idx, has := pos[val]; has { if p := sort.SearchInts(d, idx); p < len(d) { d[p] = idx } else { d = append(d, idx) } } } return n - len(d) }
func maximumTime(time string) string { t := []byte(time) if t[0] == '?' { if '4' <= t[1] && t[1] <= '9' { t[0] = '1' } else { t[0] = '2' } } if t[1] == '?' { if t[0] == '2' { t[1] = '3' } else { t[1] = '9' } } if t[3] == '?' { t[3] = '5' } if t[4] == '?' { t[4] = '9' } return string(t) }
func copyRandomList(head *Node) *Node { if head == nil { return nil } for node := head; node != nil; node = node.Next.Next { node.Next = &Node{Val: node.Val, Next: node.Next} } for node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Random.Next } } headNew := head.Next for node := head; node != nil; node = node.Next { nodeNew := node.Next node.Next = node.Next.Next if nodeNew.Next != nil { nodeNew.Next = nodeNew.Next.Next } } return headNew }
func minAbsoluteSumDiff(nums1, nums2 []int) int { rec := append(sort.IntSlice(nil), nums1...) rec.Sort() sum, maxn, n := 0, 0, len(nums1) for i, v := range nums2 { diff := abs(nums1[i] - v) sum += diff j := rec.Search(v) if j < n { maxn = max(maxn, diff-(rec[j]-v)) } if j > 0 { maxn = max(maxn, diff-(v-rec[j-1])) } } return (sum - maxn) % (1e9 + 7) }
func hIndex(citations []int) (h int) { sort.Ints(citations) for i := len(citations) - 1; i >= 0 && citations[i] > h; i-- { h++ } return }
func numSubarraysWithSum(nums []int, goal int) (ans int) { cnt := map[int]int{} sum := 0 for _, num := range nums { cnt[sum]++ sum += num ans += cnt[sum-goal] } return }
func countPairs(deliciousness []int) (ans int) { maxVal := deliciousness[0] for _, val := range deliciousness[1:] { if val > maxVal { maxVal = val } } maxSum := maxVal * 2 cnt := map[int]int{} for _, val := range deliciousness { for sum := 1; sum <= maxSum; sum <<= 1 { ans += cnt[sum-val] } cnt[val]++ } return ans % (1e9 + 7) }
func findErrorNums(nums []int) []int { ans := make([]int, 2) sort.Ints(nums) pre := 0 for _, v := range nums { if v == pre { ans[0] = v } else if v-pre > 1 { ans[1] = pre + 1 } pre = v } n := len(nums) if nums[n-1] != n { ans[1] = n } return ans }
func maxIceCream(costs []int, coins int) (ans int) { sort.Ints(costs) for _, c := range costs { if coins < c { break } coins -= c ans++ } return }
func convertToTitle(columnNumber int) string { ans := []byte{} for columnNumber > 0 { a0 := (columnNumber-1)%26 + 1 ans = append(ans, 'A'+byte(a0-1)) columnNumber = (columnNumber - a0) / 26 } for i, n := 0, len(ans); i < n/2; i++ { ans[i], ans[n-1-i] = ans[n-1-i], ans[i] } return string(ans) }
func titleToNumber(columnTitle string) (number int) { for i, multiple := len(columnTitle)-1, 1; i >= 0; i-- { k := columnTitle[i] - 'A' + 1 number += int(k) * multiple multiple *= 26 } return }
func snakesAndLadders(board [][]int) int { n := len(board) vis := make([]bool, n*n+1) type pair struct{ id, step int } q := []pair{{1, 0}} for len(q) > 0 { p := q[0] q = q[1:] for i := 1; i <= 6; i++ { nxt := p.id + i if nxt > n*n { break } r, c := id2rc(nxt, n) if board[r][c] > 0 { nxt = board[r][c] } if nxt == n*n { return p.step + 1 } if !vis[nxt] { vis[nxt] = true q = append(q, pair{nxt, p.step + 1}) } } } return -1 }
func readBinaryWatch(turnedOn int) (ans []string) { for h := uint8(0); h < 12; h++ { for m := uint8(0); m < 60; m++ { if bits.OnesCount8(h)+bits.OnesCount8(m) == turnedOn { ans = append(ans, fmt.Sprintf("%d:%02d", h, m)) } } } return }
func smallestGoodBase(n string) string { nVal, _ := strconv.Atoi(n) mMax := bits.Len(uint(nVal)) - 1 for m := mMax; m > 1; m-- { k := int(math.Pow(float64(nVal), 1/float64(m))) mul, sum := 1, 1 for i := 0; i < m; i++ { mul *= k sum += mul } if sum == nVal { return strconv.Itoa(k) } } return strconv.Itoa(nVal - 1) }
func peakIndexInMountainArray(arr []int) int { for i := 1; ; i++ { if arr[i] > arr[i+1] { return i } } }
func isCovered(ranges [][]int, left, right int) bool { diff := [52]int{} for _, r := range ranges { diff[r[0]]++ diff[r[1]+1]-- } cnt := 0 for i := 1; i <= 50; i++ { cnt += diff[i] if cnt <= 0 && left <= i && i <= right { return false } } return true }
func chalkReplacer(chalk []int, k int) int { if chalk[0] > k { return 0 } n := len(chalk) for i := 1; i < n; i++ { chalk[i] += chalk[i-1] if chalk[i] > k { return i } } k %= chalk[n-1] return sort.SearchInts(chalk, k+1) }
func largestNumber(cost []int, target int) string { dp := make([]int, target+1) for i := range dp { dp[i] = math.MinInt32 } dp[0] = 0 for _, c := range cost { for j := c; j <= target; j++ { dp[j] = max(dp[j], dp[j-c]+1) } } if dp[target] < 0 { return "0" } ans := make([]byte, 0, dp[target]) for i, j := 8, target; i >= 0; i-- { for c := cost[i]; j >= c && dp[j] == dp[j-c]+1; j -= c { ans = append(ans, byte('1'+i)) } } return string(ans) }
func change(amount int, coins []int) int { dp := make([]int, amount+1) dp[0] = 1 for _, coin := range coins { for i := coin; i <= amount; i++ { dp[i] += dp[i-coin] } } return dp[amount] }
func profitableSchemes(n, minProfit int, group, profit []int) (sum int) { const mod int = 1e9 + 7 dp := make([][]int, n+1) for i := range dp { dp[i] = make([]int, minProfit+1) dp[i][0] = 1 } for i, members := range group { earn := profit[i] for j := n; j >= members; j-- { for k := minProfit; k >= 0; k-- { dp[j][k] = (dp[j][k] + dp[j-members][max(0, k-earn)]) % mod } } } return dp[n][minProfit] }
func lastStoneWeightII(stones []int) int { sum := 0 for _, v := range stones { sum += v } m := sum / 2 dp := make([]bool, m+1) dp[0] = true for _, weight := range stones { for j := m; j >= weight; j-- { dp[j] = dp[j] || dp[j-weight] } } for j := m; ; j-- { if dp[j] { return sum - 2*j } } }
func findTargetSumWays(nums []int, target int) int { sum := 0 for _, v := range nums { sum += v } diff := sum - target if diff < 0 || diff%2 == 1 { return 0 } neg := diff / 2 dp := make([]int, neg+1) dp[0] = 1 for _, num := range nums { for j := neg; j >= num; j-- { dp[j] += dp[j-num] } } return dp[neg] }
func findMaxForm(strs []string, m, n int) int { dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for _, s := range strs { zeros := strings.Count(s, "0") ones := len(s) - zeros for j := m; j >= zeros; j-- { for k := n; k >= ones; k-- { dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones]+1) } } } return dp[m][n] }
func removeElements(head *ListNode, val int) *ListNode { if head == nil { return head } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head }
func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pa, pb := headA, headB for pa != pb { if pa == nil { pa = headB } else { pa = pa.Next } if pb == nil { pb = headA } else { pb = pb.Next } } return pa }
func findMaxLength(nums []int) (maxLength int) { mp := map[int]int{0: -1} counter := 0 for i, num := range nums { if num == 1 { counter++ } else { counter-- } if prevIndex, has := mp[counter]; has { maxLength = max(maxLength, i-prevIndex) } else { mp[counter] = i } } return }
func checkSubarraySum(nums []int, k int) bool { m := len(nums) if m < 2 { return false } mp := map[int]int{0: -1} remainder := 0 for i, num := range nums { remainder = (remainder + num) % k if prevIndex, has := mp[remainder]; has { if i-prevIndex >= 2 { return true } } else { mp[remainder] = i } } return false }
func canEat(candiesCount []int, queries [][]int) []bool { n := len(candiesCount) sum := make([]int, n) sum[0] = candiesCount[0] for i := 1; i < n; i++ { sum[i] = sum[i-1] + candiesCount[i] } ans := make([]bool, len(queries)) for i, q := range queries { favoriteType, favoriteDay, dailyCap := q[0], q[1], q[2] x1 := favoriteDay + 1 y1 := (favoriteDay + 1) * dailyCap x2 := 1 if favoriteType > 0 { x2 = sum[favoriteType-1] + 1 } y2 := sum[favoriteType] ans[i] = !(x1 > y2 || y1 < x2) } return ans }
func minPairSum(nums []int) (ans int) { sort.Ints(nums) n := len(nums) for i, val := range nums[:n/2] { ans = max(ans, val+nums[n-1-i]) } return }
func isPowerOfFour(n int) bool { return n > 0 && n&(n-1) == 0 && n&0xaaaaaaaa == 0 }
func numSubmatrixSumTarget(matrix [][]int, target int) (ans int) { for i := range matrix { sum := make([]int, len(matrix[0])) for _, row := range matrix[i:] { for c, v := range row { sum[c] += v } ans += subarraySum(sum, target) } } return }
func totalHammingDistance(nums []int) (ans int) { n := len(nums) for i := 0; i < 30; i++ { c := 0 for _, val := range nums { c += val >> i & 1 } ans += c * (n - c) } return }
func hammingDistance(x, y int) int { return bits.OnesCount(uint(x ^ y)) }
func isPowerOfTwo(n int) bool { return n > 0 && n&(n-1) == 0 }
func reverseParentheses(s string) string { stack := [][]byte{} str := []byte{} for i := range s { if s[i] == '(' { stack = append(stack, str) str = []byte{} } else if s[i] == ')' { for j, n := 0, len(str); j < n/2; j++ { str[j], str[n-1-j] = str[n-1-j], str[j] } str = append(stack[len(stack)-1], str...) stack = stack[:len(stack)-1] } else { str = append(str, s[i]) } } return string(str) }
func strangePrinter(s string) int { n := len(s) f := make([][]int, n) for i := range f { f[i] = make([]int, n) } for i := n - 1; i >= 0; i-- { f[i][i] = 1 for j := i + 1; j < n; j++ { if s[i] == s[j] { f[i][j] = f[i][j-1] } else { f[i][j] = math.MaxInt64 for k := i; k < j; k++ { f[i][j] = min(f[i][j], f[i][k]+f[k+1][j]) } } } } return f[0][n-1] }
func xorGame(nums []int) bool { if len(nums)%2 == 0 { return true } xor := 0 for _, num := range nums { xor ^= num } return xor == 0 }
func maxUncrossedLines(nums1, nums2 []int) int { m, n := len(nums1), len(nums2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i, v := range nums1 { for j, w := range nums2 { if v == w { dp[i+1][j+1] = dp[i][j] + 1 } else { dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) } } } return dp[m][n] }
func kthLargestValue(matrix [][]int, k int) int { m, n := len(matrix), len(matrix[0]) results := make([]int, 0, m*n) pre := make([][]int, m+1) pre[0] = make([]int, n+1) for i, row := range matrix { pre[i+1] = make([]int, n+1) for j, val := range row { pre[i+1][j+1] = pre[i+1][j] ^ pre[i][j+1] ^ pre[i][j] ^ val results = append(results, pre[i+1][j+1]) } } sort.Sort(sort.Reverse(sort.IntSlice(results))) return results[k-1] }
func findMaximumXOR(nums []int) (x int) { const highBit = 30 for k := highBit; k >= 0; k-- { seen := map[int]bool{} for _, num := range nums { seen[num>>k] = true } xNext := x*2 + 1 found := false for _, num := range nums { if seen[num>>k^xNext] { found = true break } } if found { x = xNext } else { x = xNext - 1 } } return }
func romanToInt(s string) (ans int) { n := len(s) for i := range s { value := symbolValues[s[i]] if i < n-1 && value < symbolValues[s[i+1]] { ans -= value } else { ans += value } } return }
func intToRoman(num int) string { roman := []byte{} for _, vs := range valueSymbols { for num >= vs.value { num -= vs.value roman = append(roman, vs.symbol...) } if num == 0 { break } } return string(roman) }
func decode(encoded []int) []int { n := len(encoded) total := 0 for i := 1; i <= n+1; i++ { total ^= i } odd := 0 for i := 1; i < n; i += 2 { odd ^= encoded[i] } perm := make([]int, n+1) perm[0] = total ^ odd for i, v := range encoded { perm[i+1] = perm[i] ^ v } return perm }
func decode(encoded []int, first int) []int { ans := make([]int, len(encoded)+1) ans[0] = first for i, e := range encoded { ans[i+1] = ans[i] ^ e } return ans }
func rob(nums []int) int { first, second := nums[0], max(nums[0], nums[1]) for i := 2; i < len(nums); i++ { first, second = second, max(first+nums[i], second) } return second }
func reverse(x int) (rev int) { for x != 0 { if rev < math.MinInt32/10 || rev > math.MaxInt32/10 { return 0 } digit := x % 10 x /= 10 rev = rev*10 + digit } return }
func maximumElementAfterDecrementingAndRearranging(arr []int) int { n := len(arr) sort.Ints(arr) arr[0] = 1 for i := 1; i < n; i++ { arr[i] = min(arr[i], arr[i-1]+1) } return arr[n-1] }
func judgeSquareSum(c int) bool { for a := 0; a*a <= c; a++ { rt := math.Sqrt(float64(c - a*a)) if rt == math.Floor(rt) { return true } } return false }
func canCross(stones []int) bool { n := len(stones) dp := make([][]bool, n) for i := range dp { dp[i] = make([]bool, n) } dp[0][0] = true for i := 1; i < n; i++ { if stones[i]-stones[i-1] > i { return false } } for i := 1; i < n; i++ { for j := i - 1; j >= 0; j-- { k := stones[i] - stones[j] if k > j+1 { break } dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1] if i == n-1 && dp[i][k] { return true } } } return false }
func singleNumber(nums []int) int { ans := int32(0) for i := 0; i < 32; i++ { total := int32(0) for _, num := range nums { total += int32(num) >> i & 1 } if total%3 > 0 { ans |= 1 << i } } return int(ans) }
func rangeSumBST(root *TreeNode, low, high int) int { if root == nil { return 0 } if root.Val > high { return rangeSumBST(root.Left, low, high) } if root.Val < low { return rangeSumBST(root.Right, low, high) } return root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high) }
func maxFrequency(nums []int, k int) int { sort.Ints(nums) ans := 1 for l, r, total := 0, 1, 0; r < len(nums); r++ { total += (nums[r] - nums[r-1]) * (r - l) for total > k { total -= nums[r] - nums[l] l++ } ans = max(ans, r-l+1) } return ans }
func combinationSum4(nums []int, target int) int { dp := make([]int, target+1) dp[0] = 1 for i := 1; i <= target; i++ { for _, num := range nums { if num <= i { dp[i] += dp[i-num] } } } return dp[target] }
func numDecodings(s string) int { n := len(s) f := make([]int, n+1) f[0] = 1 for i := 1; i <= n; i++ { if s[i-1] != '0' { f[i] += f[i-1] } if i > 1 && s[i-2] != '0' && ((s[i-2]-'0')*10+(s[i-1]-'0') <= 26) { f[i] += f[i-2] } } return f[n] }
func strStr(haystack, needle string) int { n, m := len(haystack), len(needle) outer: for i := 0; i+m <= n; i++ { for j := range needle { if haystack[i+j] != needle[j] { continue outer } } return i } return -1 }
func removeElement(nums []int, val int) int { left := 0 for _, v := range nums { if v != val { nums[left] = v left++ } } return left }
func removeDuplicates(nums []int) int { n := len(nums) if n == 0 { return 0 } slow := 1 for fast := 1; fast < n; fast++ { if nums[fast] != nums[fast-1] { nums[slow] = nums[fast] slow++ } } return slow }
func containsNearbyAlmostDuplicate(nums []int, k, t int) bool { mp := map[int]int{} for i, x := range nums { id := getID(x, t+1) if _, has := mp[id]; has { return true } if y, has := mp[id-1]; has && abs(x-y) <= t { return true } if y, has := mp[id+1]; has && abs(x-y) <= t { return true } mp[id] = x if i >= k { delete(mp, getID(nums[i-k], t+1)) } } return false }
func rob(nums []int) int { n := len(nums) if n == 1 { return nums[0] } if n == 2 { return max(nums[0], nums[1]) } return max(_rob(nums[:n-1]), _rob(nums[1:])) }
func isUgly(n int) bool { if n <= 0 { return false } for _, f := range factors { for n%f == 0 { n /= f } } return n == 1 }
func nthUglyNumber(n int) int { dp := make([]int, n+1) dp[1] = 1 p2, p3, p5 := 1, 1, 1 for i := 2; i <= n; i++ { x2, x3, x5 := dp[p2]*2, dp[p3]*3, dp[p5]*5 dp[i] = min(min(x2, x3), x5) if dp[i] == x2 { p2++ } if dp[i] == x3 { p3++ } if dp[i] == x5 { p5++ } } return dp[n] }
func search(nums []int, target int) bool { n := len(nums) if n == 0 { return false } if n == 1 { return nums[0] == target } l, r := 0, n-1 for l <= r { mid := (l + r) / 2 if nums[mid] == target { return true } if nums[l] == nums[mid] && nums[mid] == nums[r] { l++ r-- } else if nums[l] <= nums[mid] { if nums[l] <= target && target < nums[mid] { r = mid - 1 } else { l = mid + 1 } } else { if nums[mid] < target && target <= nums[n-1] { l = mid + 1 } else { r = mid - 1 } } } return false }
func removeDuplicates(nums []int) int { n := len(nums) if n <= 2 { return n } slow, fast := 2, 2 for fast < n { if nums[slow-2] != nums[fast] { nums[slow] = nums[fast] slow++ } fast++ } return slow }
func findMin(nums []int) int { low, high := 0, len(nums) - 1 for low < high { pivot := low + (high - low) / 2 if nums[pivot] < nums[high] { high = pivot } else { low = pivot + 1 } } return nums[low] }
func numRabbits(answers []int) (ans int) { count := map[int]int{} for _, y := range answers { count[y]++ } for y, x := range count { ans += (x + y) / (y + 1) * (y + 1) } return }
func longestCommonSubsequence(text1, text2 string) int { m, n := len(text1), len(text2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i, c1 := range text1 { for j, c2 := range text2 { if c1 == c2 { dp[i+1][j+1] = dp[i][j] + 1 } else { dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) } } } return dp[m][n] }
func trap(height []int) (ans int) { stack := []int{} for i, h := range height { for len(stack) > 0 && h > height[stack[len(stack)-1]] { top := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) == 0 { break } left := stack[len(stack)-1] curWidth := i - left - 1 curHeight := min(height[left], h) - height[top] ans += curWidth * curHeight } stack = append(stack, i) } return }
func reverseBits(n uint32) (rev uint32) { for i := 0; i < 32 && n > 0; i++ { rev |= n & 1 << (31 - i) n >>= 1 } return }
func rotateRight(head *ListNode, k int) *ListNode { if k == 0 || head == nil || head.Next == nil { return head } n := 1 iter := head for iter.Next != nil { iter = iter.Next n++ } add := n - k%n if add == n { return head } iter.Next = head for add > 0 { iter = iter.Next add-- } ret := iter.Next iter.Next = nil return ret }
func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } cur := head for cur.Next != nil { if cur.Val == cur.Next.Val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return head }
func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } dummy := &ListNode{0, head} cur := dummy for cur.Next != nil && cur.Next.Next != nil { if cur.Next.Val == cur.Next.Next.Val { x := cur.Next.Val for cur.Next != nil && cur.Next.Val == x { cur.Next = cur.Next.Next } } else { cur = cur.Next } } return dummy.Next }
func find132pattern(nums []int) bool { n := len(nums) candidateK := []int{nums[n-1]} maxK := math.MinInt64 for i := n - 2; i >= 0; i-- { if nums[i] < maxK { return true } for len(candidateK) > 0 && nums[i] > candidateK[len(candidateK)-1] { maxK = candidateK[len(candidateK)-1] candidateK = candidateK[:len(candidateK)-1] } if nums[i] > maxK { candidateK = append(candidateK, nums[i]) } } return false }
func hammingWeight(num uint32) (ones int) { for i := 0; i < 32; i++ { if 1<<i&num > 0 { ones++ } } return }
func setZeroes(matrix [][]int) { row := make([]bool, len(matrix)) col := make([]bool, len(matrix[0])) for i, r := range matrix { for j, v := range r { if v == 0 { row[i] = true col[j] = true } } } for i, r := range matrix { for j := range r { if row[i] || col[j] { r[j] = 0 } } } }
func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[len(stack)-1] stack = stack[:len(stack)-2] switch token { case "+": stack = append(stack, num1+num2) case "-": stack = append(stack, num1-num2) case "*": stack = append(stack, num1*num2) default: stack = append(stack, num1/num2) } } } return stack[0] }
func merge(nums1 []int, m int, nums2 []int, n int) { for p1, p2, tail := m-1, n-1, m+n-1; p1 >= 0 || p2 >= 0; tail-- { var cur int if p1 == -1 { cur = nums2[p2] p2-- } else if p2 == -1 { cur = nums1[p1] p1-- } else if nums1[p1] > nums2[p2] { cur = nums1[p1] p1-- } else { cur = nums2[p2] p2-- } nums1[tail] = cur } }
func nthPersonGetsNthSeat(n int) float64 { if n == 1 { return 1.0 } return 0.5 }
func numDistinct(s, t string) int { m, n := len(s), len(t) if m < n { return 0 } dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) dp[i][n] = 1 } for i := m - 1; i >= 0; i-- { for j := n - 1; j >= 0; j-- { if s[i] == t[j] { dp[i][j] = dp[i+1][j+1] + dp[i+1][j] } else { dp[i][j] = dp[i+1][j] } } } return dp[0][0] }
func generateMatrix(n int) [][]int { matrix := make([][]int, n) for i := range matrix { matrix[i] = make([]int, n) } num := 1 left, right, top, bottom := 0, n-1, 0, n-1 for left <= right && top <= bottom { for column := left; column <= right; column++ { matrix[top][column] = num num++ } for row := top + 1; row <= bottom; row++ { matrix[row][right] = num num++ } if left < right && top < bottom { for column := right - 1; column > left; column-- { matrix[bottom][column] = num num++ } for row := bottom; row > top; row-- { matrix[row][left] = num num++ } } left++ right-- top++ bottom-- } return matrix }
func isValidSerialization(preorder string) bool { n := len(preorder) slots := 1 for i := 0; i < n; { if slots == 0 { return false } if preorder[i] == ',' { i++ } else if preorder[i] == '#' { slots-- i++ } else { for i < n && preorder[i] != ',' { i++ } slots++ } } return slots == 0 }
func calculate(s string) (ans int) { stack := []int{} preSign := '+' num := 0 for i, ch := range s { isDigit := '0' <= ch && ch <= '9' if isDigit { num = num*10 + int(ch-'0') } if !isDigit && ch != ' ' || i == len(s)-1 { switch preSign { case '+': stack = append(stack, num) case '-': stack = append(stack, -num) case '*': stack[len(stack)-1] *= num default: stack[len(stack)-1] /= num } preSign = ch num = 0 } } for _, v := range stack { ans += v } return }
func removeDuplicates(s string) string { stack := []byte{} for i := range s { if len(stack) > 0 && stack[len(stack)-1] == s[i] { stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return string(stack) }
func minCut(s string) int { n := len(s) g := make([][]bool, n) for i := range g { g[i] = make([]bool, n) for j := range g[i] { g[i][j] = true } } for i := n - 1; i >= 0; i-- { for j := i + 1; j < n; j++ { g[i][j] = s[i] == s[j] && g[i+1][j-1] } } f := make([]int, n) for i := range f { if g[0][i] { continue } f[i] = math.MaxInt64 for j := 0; j < i; j++ { if g[j+1][i] && f[j]+1 < f[i] { f[i] = f[j] + 1 } } } return f[n-1] }
func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) for i := range ans { ans[i] = -1 } stack := []int{} for i := 0; i < n*2-1; i++ { for len(stack) > 0 && nums[stack[len(stack)-1]] < nums[i%n] { ans[stack[len(stack)-1]] = nums[i%n] stack = stack[:len(stack)-1] } stack = append(stack, i%n) } return ans }
func reverseBetween(head *ListNode, left, right int) *ListNode { dummyNode := &ListNode{Val: -1} dummyNode.Next = head pre := dummyNode for i := 0; i < left-1; i++ { pre = pre.Next } cur := pre.Next for i := 0; i < right-left; i++ { next := cur.Next cur.Next = next.Next next.Next = pre.Next pre.Next = next } return dummyNode.Next }
func maxEnvelopes(envelopes [][]int) int { n := len(envelopes) if n == 0 { return 0 } sort.Slice(envelopes, func(i, j int) bool { a, b := envelopes[i], envelopes[j] return a[0] < b[0] || a[0] == b[0] && a[1] > b[1] }) f := make([]int, n) for i := range f { f[i] = 1 } for i := 1; i < n; i++ { for j := 0; j < i; j++ { if envelopes[j][1] < envelopes[i][1] { f[i] = max(f[i], f[j]+1) } } } return max(f...) }
func countBits(n int) []int { bits := make([]int, n+1) highBit := 0 for i := 1; i <= n; i++ { if i&(i-1) == 0 { highBit = i } bits[i] = bits[i-highBit] + 1 } return bits }
func longestSubstring(s string, k int) (ans int) { for t := 1; t <= 26; t++ { cnt := [26]int{} total := 0 lessK := 0 l := 0 for r, ch := range s { ch -= 'a' if cnt[ch] == 0 { total++ lessK++ } cnt[ch]++ if cnt[ch] == k { lessK-- } for total > t { ch := s[l] - 'a' if cnt[ch] == k { lessK++ } cnt[ch]-- if cnt[ch] == 0 { total-- lessK-- } l++ } if lessK == 0 { ans = max(ans, r-l+1) } } } return ans }
func flipAndInvertImage(image [][]int) [][]int { for _, row := range image { left, right := 0, len(row)-1 for left < right { if row[left] == row[right] { row[left] ^= 1 row[right] ^= 1 } left++ right-- } if left == right { row[left] ^= 1 } } return image }
func maxSatisfied(customers []int, grumpy []int, minutes int) int { total := 0 n := len(customers) for i := 0; i < n; i++ { if grumpy[i] == 0 { total += customers[i] } } increase := 0 for i := 0; i < minutes; i++ { increase += customers[i] * grumpy[i] } maxIncrease := increase for i := minutes; i < n; i++ { increase = increase - customers[i-minutes]*grumpy[i-minutes] + customers[i]*grumpy[i] maxIncrease = max(maxIncrease, increase) } return total + maxIncrease }
func isToeplitzMatrix(matrix [][]int) bool { n, m := len(matrix), len(matrix[0]) for i := 1; i < n; i++ { for j := 1; j < m; j++ { if matrix[i][j] != matrix[i-1][j-1] { return false } } } return true }
func findShortestSubArray(nums []int) (ans int) { mp := map[int]entry{} for i, v := range nums { if e, has := mp[v]; has { e.cnt++ e.r = i mp[v] = e } else { mp[v] = entry{1, i, i} } } maxCnt := 0 for _, e := range mp { if e.cnt > maxCnt { maxCnt, ans = e.cnt, e.r-e.l+1 } else if e.cnt == maxCnt { ans = min(ans, e.r-e.l+1) } } return }
func longestOnes(nums []int, k int) (ans int) { n := len(nums) P := make([]int, n+1) for i, v := range nums { P[i+1] = P[i] + 1 - v } for right, v := range P { left := sort.SearchInts(P, v-k) ans = max(ans, right-left) } return }
func minKBitFlips(nums []int, k int) (ans int) { n := len(nums) diff := make([]int, n+1) revCnt := 0 for i, v := range nums { revCnt ^= diff[i] if v == revCnt { if i+k > n { return -1 } ans++ revCnt ^= 1 diff[i+k] ^= 1 } } return }
func matrixReshape(nums [][]int, r int, c int) [][]int { n, m := len(nums), len(nums[0]) if n*m != r*c { return nums } ans := make([][]int, r) for i := range ans { ans[i] = make([]int, c) } for i := 0; i < n*m; i++ { ans[i/c][i%c] = nums[i/m][i%m] } return ans }
func arrayPairSum(nums []int) (ans int) { sort.Ints(nums) for i := 0; i < len(nums); i += 2 { ans += nums[i] } return }
func findMaxConsecutiveOnes(nums []int) (maxCnt int) { cnt := 0 for _, v := range nums { if v == 1 { cnt++ } else { maxCnt = max(maxCnt, cnt) cnt = 0 } } maxCnt = max(maxCnt, cnt) return }
func findDisappearedNumbers(nums []int) (ans []int) { n := len(nums) for _, v := range nums { v = (v - 1) % n nums[v] += n } for i, v := range nums { if v <= n { ans = append(ans, i+1) } } return }
func getRow(rowIndex int) []int { var pre, cur []int for i := 0; i <= rowIndex; i++ { cur = make([]int, i+1) cur[0], cur[i] = 1, 1 for j := 1; j < i; j++ { cur[j] = pre[j-1] + pre[j] } pre = cur } return pre }
func checkInclusion(s1, s2 string) bool { n, m := len(s1), len(s2) if n > m { return false } var cnt1, cnt2 [26]int for i, ch := range s1 { cnt1[ch-'a']++ cnt2[s2[i]-'a']++ } if cnt1 == cnt2 { return true } for i := n; i < m; i++ { cnt2[s2[i]-'a']++ cnt2[s2[i-n]-'a']-- if cnt1 == cnt2 { return true } } return false }
func subarraysWithKDistinct(nums []int, k int) (ans int) { n := len(nums) num1 := make([]int, n+1) num2 := make([]int, n+1) var tot1, tot2, left1, left2 int for _, v := range nums { if num1[v] == 0 { tot1++ } num1[v]++ if num2[v] == 0 { tot2++ } num2[v]++ for tot1 > k { num1[nums[left1]]-- if num1[nums[left1]] == 0 { tot1-- } left1++ } for tot2 > k-1 { num2[nums[left2]]-- if num2[nums[left2]] == 0 { tot2-- } left2++ } ans += left2 - left1 } return ans }
func maxTurbulenceSize(arr []int) int { n := len(arr) ans := 1 left, right := 0, 0 for right < n-1 { if left == right { if arr[left] == arr[left+1] { left++ } right++ } else { if arr[right-1] < arr[right] && arr[right] > arr[right+1] { right++ } else if arr[right-1] > arr[right] && arr[right] < arr[right+1] { right++ } else { left = right } } ans = max(ans, right-left+1) } return ans }
func checkPossibility(nums []int) bool { for i := 0; i < len(nums)-1; i++ { x, y := nums[i], nums[i+1] if x > y { nums[i] = y if sort.IntsAreSorted(nums) { return true } nums[i] = x nums[i+1] = x return sort.IntsAreSorted(nums) } } return true }
func equalSubstring(s string, t string, maxCost int) (maxLen int) { n := len(s) accDiff := make([]int, n+1) for i, ch := range s { accDiff[i+1] = accDiff[i] + abs(int(ch)-int(t[i])) } for i := 1; i <= n; i++ { start := sort.SearchInts(accDiff[:i], accDiff[i]-maxCost) maxLen = max(maxLen, i-start) } return }
func findMaxAverage(nums []int, k int) float64 { sum := 0 for _, v := range nums[:k] { sum += v } maxSum := sum for i := k; i < len(nums); i++ { sum = sum - nums[i-k] + nums[i] maxSum = max(maxSum, sum) } return float64(maxSum) / float64(k) }
func singleNumber(nums []int) []int { xorSum := 0 for _, num := range nums { xorSum ^= num } lsb := xorSum & -xorSum type1, type2 := 0, 0 for _, num := range nums { if num&lsb > 0 { type1 ^= num } else { type2 ^= num } } return []int{type1, type2} }
func characterReplacement(s string, k int) int { cnt := [26]int{} maxCnt, left := 0, 0 for right, ch := range s { cnt[ch-'A']++ maxCnt = max(maxCnt, cnt[ch-'A']) if right-left+1-maxCnt > k { cnt[s[left]-'A']-- left++ } } return len(s) - left }
func countTriplets(arr []int) (ans int) { n := len(arr) s := make([]int, n+1) for i, val := range arr { s[i+1] = s[i] ^ val } for i := 0; i < n; i++ { for j := i + 1; j < n; j++ { for k := j; k < n; k++ { if s[i] == s[k+1] { ans++ } } } } return }
func pivotIndex(nums []int) int { total := 0 for _, v := range nums { total += v } sum := 0 for i, v := range nums { if 2*sum+v == total { return i } sum += v } return -1 }
func findLengthOfLCIS(nums []int) (ans int) { start := 0 for i, v := range nums { if i > 0 && v <= nums[i-1] { start = i } ans = max(ans, i-start+1) } return }
func addToArrayForm(num []int, k int) (ans []int) { for i := len(num) - 1; i >= 0 || k > 0; i-- { if i >= 0 { k += num[i] } ans = append(ans, k%10) k /= 10 } reverse(ans) return }
func maximumProduct(nums []int) int { sort.Ints(nums) n := len(nums) return max(nums[0]*nums[1]*nums[n-1], nums[n-3]*nums[n-2]*nums[n-1]) }
func checkStraightLine(coordinates [][]int) bool { deltaX, deltaY := coordinates[0][0], coordinates[0][1] for _, p := range coordinates { p[0] -= deltaX p[1] -= deltaY } A, B := coordinates[1][1], -coordinates[1][0] for _, p := range coordinates[2:] { x, y := p[0], p[1] if A*x+B*y != 0 { return false } } return true }
func prefixesDivBy5(nums []int) []bool { ans := make([]bool, len(nums)) x := 0 for i, v := range nums { x = (x<<1 | v) % 5 ans[i] = x == 0 } return ans }
func maxProfit(prices []int) int { buy1, sell1 := -prices[0], 0 buy2, sell2 := -prices[0], 0 for i := 1; i < len(prices); i++ { buy1 = max(buy1, -prices[i]) sell1 = max(sell1, buy1+prices[i]) buy2 = max(buy2, sell1-prices[i]) sell2 = max(sell2, buy2+prices[i]) } return sell2 }
func reverseList(head *ListNode) *ListNode { var prev *ListNode curr := head for curr != nil { next := curr.Next curr.Next = prev prev = curr curr = next } return prev }
func rotate(nums []int, k int) { newNums := make([]int, len(nums)) for i, v := range nums { newNums[(i+k)%len(nums)] = v } copy(nums, newNums) }
func largeGroupPositions(s string) (ans [][]int) { cnt := 1 for i := range s { if i == len(s)-1 || s[i] != s[i+1] { if cnt >= 3 { ans = append(ans, []int{i - cnt + 1, i}) } cnt = 1 } else { cnt++ } } return }
func fib(n int) int { if n < 2 { return n } p, q, r := 0, 0, 1 for i := 2; i <= n; i++ { p = q q = r r = p + q } return r }
func partition(head *ListNode, x int) *ListNode { small := &ListNode{} smallHead := small large := &ListNode{} largeHead := large for head != nil { if head.Val < x { small.Next = head small = small.Next } else { large.Next = head large = large.Next } head = head.Next } large.Next = nil small.Next = largeHead.Next return smallHead.Next }
func maxSlidingWindow(nums []int, k int) []int { n := len(nums) prefixMax := make([]int, n) suffixMax := make([]int, n) for i, v := range nums { if i%k == 0 { prefixMax[i] = v } else { prefixMax[i] = max(prefixMax[i-1], v) } } for i := n - 1; i >= 0; i-- { if i == n-1 || (i+1)%k == 0 { suffixMax[i] = nums[i] } else { suffixMax[i] = max(suffixMax[i+1], nums[i]) } } ans := make([]int, n-k+1) for i := range ans { ans[i] = max(suffixMax[i], prefixMax[i+k-1]) } return ans }
func canPlaceFlowers(flowerbed []int, n int) bool { count := 0 m := len(flowerbed) prev := -1 for i := 0; i < m; i++ { if flowerbed[i] == 1 { if prev < 0 { count += i / 2 } else { count += (i - prev - 2) / 2 } prev = i } } if prev < 0 { count += (m + 1) / 2 } else { count += (m - prev - 1) / 2 } return count >= n }
func eraseOverlapIntervals(intervals [][]int) int { n := len(intervals) if n == 0 { return 0 } sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] < intervals[j][1] }) ans, right := 1, intervals[0][1] for _, p := range intervals[1:] { if p[0] >= right { ans++ right = p[1] } } return n - ans }
func lastStoneWeight(stones []int) int { q := &hp{stones} heap.Init(q) for q.Len() > 1 { x, y := q.pop(), q.pop() if x > y { q.push(x - y) } } if q.Len() > 0 { return q.IntSlice[0] } return 0 }
func minPatches(nums []int, n int) (patches int) { for i, x := 0, 1; x <= n; { if i < len(nums) && nums[i] <= x { x += nums[i] i++ } else { x *= 2 patches++ } } return }
func isIsomorphic(s, t string) bool { s2t := map[byte]byte{} t2s := map[byte]byte{} for i := range s { x, y := s[i], t[i] if s2t[x] > 0 && s2t[x] != y || t2s[y] > 0 && t2s[y] != x { return false } s2t[x] = y t2s[y] = x } return true }
func findContentChildren(greed, size []int) (ans int) { sort.Ints(greed) sort.Ints(size) n, m := len(greed), len(size) for i, j := 0, 0; i < n && j < m; i++ { for j < m && greed[i] > size[j] { j++ } if j < m { ans++ j++ } } return }
func candy(ratings []int) (ans int) { n := len(ratings) left := make([]int, n) for i, r := range ratings { if i > 0 && r > ratings[i-1] { left[i] = left[i-1] + 1 } else { left[i] = 1 } } right := 0 for i := n - 1; i >= 0; i-- { if i < n-1 && ratings[i] > ratings[i+1] { right++ } else { right = 1 } ans += max(left[i], right) } return }
func firstUniqChar(s string) int { cnt := [26]int{} for _, ch := range s { cnt[ch-'a']++ } for i, ch := range s { if cnt[ch-'a'] == 1 { return i } } return -1 }
func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n+1) for i := 2; i <= n; i++ { dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]) } return dp[n] }
func rotate(matrix [][]int) { n := len(matrix) tmp := make([][]int, n) for i := range tmp { tmp[i] = make([]int, n) } for i, row := range matrix { for j, v := range row { tmp[j][n-1-i] = v } } copy(matrix, tmp) }
func findTheDifference(s, t string) byte { cnt := [26]int{} for _, ch := range s { cnt[ch-'a']++ } for i := 0; ; i++ { ch := t[i] cnt[ch-'a']-- if cnt[ch-'a'] < 0 { return ch } } }
func maxProfit(prices []int, fee int) int { n := len(prices) dp := make([][2]int, n) dp[0][1] = -prices[0] for i := 1; i < n; i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee) dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) } return dp[n-1][0] }
func monotoneIncreasingDigits(n int) int { s := []byte(strconv.Itoa(n)) i := 1 for i < len(s) && s[i] >= s[i-1] { i++ } if i < len(s) { for i > 0 && s[i] < s[i-1] { s[i-1]-- i-- } for i++; i < len(s); i++ { s[i] = '9' } } ans, _ := strconv.Atoi(string(s)) return ans }
func containsDuplicate(nums []int) bool { sort.Ints(nums) for i := 1; i < len(nums); i++ { if nums[i] == nums[i-1] { return true } } return false }
func wiggleMaxLength(nums []int) int { n := len(nums) if n < 2 { return n } up := make([]int, n) down := make([]int, n) up[0] = 1 down[0] = 1 for i := 1; i < n; i++ { if nums[i] > nums[i-1] { up[i] = max(up[i-1], down[i-1]+1) down[i] = down[i-1] } else if nums[i] < nums[i-1] { up[i] = up[i-1] down[i] = max(up[i-1]+1, down[i-1]) } else { up[i] = up[i-1] down[i] = down[i-1] } } return max(up[n-1], down[n-1]) }
func predictPartyVictory(senate string) string { var radiant, dire []int for i, s := range senate { if s == 'R' { radiant = append(radiant, i) } else { dire = append(dire, i) } } for len(radiant) > 0 && len(dire) > 0 { if radiant[0] < dire[0] { radiant = append(radiant, radiant[0]+len(senate)) } else { dire = append(dire, dire[0]+len(senate)) } radiant = radiant[1:] dire = dire[1:] } if len(radiant) > 0 { return "Radiant" } return "Dire" }
func lemonadeChange(bills []int) bool { five, ten := 0, 0 for _, bill := range bills { if bill == 5 { five++ } else if bill == 10 { if five == 0 { return false } five-- ten++ } else { if five > 0 && ten > 0 { five-- ten-- } else if five >= 3 { five -= 3 } else { return false } } } return true }
