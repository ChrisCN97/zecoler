def twoSum(self, nums: List[int], target: int) -> List[int]: n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target: return [i, j] return []
def reverse(self, x: int) -> int: INT_MIN, INT_MAX = -2**31, 2**31 - 1 rev = 0 while x != 0: if rev < INT_MIN // 10 + 1 or rev > INT_MAX // 10: return 0 digit = x % 10 if x < 0 and digit > 0: digit -= 10 x = (x - digit) // 10 rev = rev * 10 + digit return rev
def romanToInt(self, s: str) -> int: ans = 0 n = len(s) for i, ch in enumerate(s): value = SYMBOL_VALUES[ch] if i < n - 1 and value < SYMBOL_VALUES[s[i + 1]]: ans -= value else: ans += value return ans
def longestCommonPrefix(self, strs: List[str]) -> str: if not strs: return "" prefix, count = strs[0], len(strs) for i in range(1, count): prefix = self.lcp(prefix, strs[i]) if not prefix: break return prefix
def isValid(self, s: str) -> bool: if len(s) % 2 == 1: return False pairs = { ")": "(", "]": "[", "}": "{", } stack = list() for ch in s: if ch in pairs: if not stack or stack[-1] != pairs[ch]: return False stack.pop() else: stack.append(ch) return not stack
def removeDuplicates(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) fast = slow = 1 while fast < n: if nums[fast] != nums[fast - 1]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow
def plusOne(self, digits: List[int]) -> List[int]: n = len(digits) for i in range(n - 1, -1, -1): if digits[i] != 9: digits[i] += 1 for j in range(i + 1, n): digits[j] = 0 return digits return [1] + [0] * n
def mySqrt(self, x: int) -> int: if x == 0: return 0 C, x0 = float(x), float(x) while True: xi = 0.5 * (x0 + C / x0) if abs(x0 - xi) < 1e-7: break x0 = xi return int(x0)
def deleteDuplicates(self, head: ListNode) -> ListNode: if not head: return head cur = head while cur.next: if cur.val == cur.next.val: cur.next = cur.next.next else: cur = cur.next return head
def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None: nums1[m:] = nums2 nums1.sort()
def numDecodings(self, s: str) -> int: n = len(s) f = [1] + [0] * n for i in range(1, n + 1): if s[i - 1] != '0': f[i] += f[i - 1] if i > 1 and s[i - 2] != '0' and int(s[i-2:i]) <= 26: f[i] += f[i - 2] return f[n]
def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode: dummy_node = ListNode(-1) dummy_node.next = head pre = dummy_node for _ in range(left - 1): pre = pre.next cur = pre.next for _ in range(right - left): next = cur.next cur.next = next.next next.next = pre.next pre.next = next return dummy_node.next
def generateTrees(start, end): if start > end: return [None,] allTrees = [] for i in range(start, end + 1): leftTrees = generateTrees(start, i - 1) rightTrees = generateTrees(i + 1, end) for l in leftTrees: for r in rightTrees: currTree = TreeNode(i) currTree.left = l currTree.right = r allTrees.append(currTree) return allTrees
def numTrees(self, n): C = 1 for i in range(0, n): C = C * 2*(2*i+1)/(i+2) return int(C)
def isValidBST(self, root: TreeNode) -> bool: stack, inorder = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() if root.val <= inorder: return False inorder = root.val root = root.right return True
def isSameTree(self, p: TreeNode, q: TreeNode) -> bool: if not p and not q: return True elif not p or not q: return False elif p.val != q.val: return False else: return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
def maxDepth(self, root): if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height, right_height) + 1
def levelOrderBottom(self, root: TreeNode) -> List[List[int]]: levelOrder = list() if not root: return levelOrder q = collections.deque([root]) while q: level = list() size = len(q) for _ in range(size): node = q.popleft() level.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) levelOrder.append(level) return levelOrder[::-1]
def helper(left, right): if left > right: return None mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = helper(left, mid - 1) root.right = helper(mid + 1, right) return root
def minDepth(self, root: TreeNode) -> int: if not root: return 0 if not root.left and not root.right: return 1 min_depth = 10**9 if root.left: min_depth = min(self.minDepth(root.left), min_depth) if root.right: min_depth = min(self.minDepth(root.right), min_depth) return min_depth + 1
def hasPathSum(self, root: TreeNode, sum: int) -> bool: if not root: return False if not root.left and not root.right: return sum == root.val return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
def flatten(self, root: TreeNode) -> None: preorderList = list() stack = list() node = root while node or stack: while node: preorderList.append(node) stack.append(node) node = node.left node = stack.pop() node = node.right size = len(preorderList) for i in range(1, size): prev, curr = preorderList[i - 1], preorderList[i] prev.left = None prev.right = curr
def connect(self, root: 'Node') -> 'Node': if not root: return root Q = collections.deque([root]) while Q: size = len(Q) for i in range(size): node = Q.popleft() if i < size - 1: node.next = Q[0] if node.left: Q.append(node.left) if node.right: Q.append(node.right) return root
def generate(self, numRows: int) -> List[List[int]]: ret = list() for i in range(numRows): row = list() for j in range(0, i + 1): if j == 0 or j == i: row.append(1) else: row.append(ret[i - 1][j] + ret[i - 1][j - 1]) ret.append(row) return ret
def minimumTotal(self, triangle: List[List[int]]) -> int: n = len(triangle) f = [[0] * n for _ in range(2)] f[0][0] = triangle[0][0] for i in range(1, n): curr, prev = i % 2, 1 - i % 2 f[curr][0] = f[prev][0] + triangle[i][0] for j in range(1, i): f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j] f[curr][i] = f[prev][i - 1] + triangle[i][i] return min(f[(n - 1) % 2])
def maxPathSum(self, root: TreeNode) -> int: def maxGain(node): if not node: return 0 leftGain = max(maxGain(node.left), 0) rightGain = max(maxGain(node.right), 0) priceNewpath = node.val + leftGain + rightGain self.maxSum = max(self.maxSum, priceNewpath) return node.val + max(leftGain, rightGain) maxGain(root) return self.maxSum
def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int: def addWord(word: str): if word not in wordId: nonlocal nodeNum wordId[word] = nodeNum nodeNum += 1 def addEdge(word: str): addWord(word) id1 = wordId[word] chars = list(word) for i in range(len(chars)): tmp = chars[i] chars[i] = "*" newWord = "".join(chars) addWord(newWord) id2 = wordId[newWord] edge[id1].append(id2) edge[id2].append(id1) chars[i] = tmp wordId = dict() edge = collections.defaultdict(list) nodeNum = 0 for word in wordList: addEdge(word) addEdge(beginWord) if endWord not in wordId: return 0 dis = [float("inf")] * nodeNum beginId, endId = wordId[beginWord], wordId[endWord] dis[beginId] = 0 que = collections.deque([beginId]) while que: x = que.popleft() if x == endId: return dis[endId] // 2 + 1 for it in edge[x]: if dis[it] == float("inf"): dis[it] = dis[x] + 1 que.append(it) return 0
def longestConsecutive(self, nums: List[int]) -> int: longest_streak = 0 num_set = set(nums) for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak
def partition(self, s: str) -> List[List[str]]: n = len(s) f = [[True] * n for _ in range(n)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): f[i][j] = (s[i] == s[j]) and f[i + 1][j - 1] ret = list() ans = list() def dfs(i: int): if i == n: ret.append(ans[:]) return for j in range(i, n): if f[i][j]: ans.append(s[i:j+1]) dfs(j + 1) ans.pop() dfs(0) return ret
def cloneGraph(self, node): if not node: return node visited = {} queue = deque([node]) visited[node] = Node(node.val, []) while queue: n = queue.popleft() for neighbor in n.neighbors: if neighbor not in visited: visited[neighbor] = Node(neighbor.val, []) queue.append(neighbor) visited[n].neighbors.append(visited[neighbor]) return visited[node]
def candy(self, ratings: List[int]) -> int: n = len(ratings) ret = 1 inc, dec, pre = 1, 0, 1 for i in range(1, n): if ratings[i] >= ratings[i - 1]: dec = 0 pre = (1 if ratings[i] == ratings[i - 1] else pre + 1) ret += pre inc = pre else: dec += 1 if dec == inc: dec += 1 ret += dec pre = 1 return ret
def singleNumber(self, nums: List[int]) -> int: ans = 0 for i in range(32): total = sum((num >> i) & 1 for num in nums) if total % 3: if i == 31: ans -= (1 << i) else: ans |= (1 << i) return ans
def hasCycle(self, head: ListNode) -> bool: seen = set() while head: if head in seen: return True seen.add(head) head = head.next return False
def reorderList(self, head: ListNode) -> None: if not head: return vec = list() node = head while node: vec.append(node) node = node.next i, j = 0, len(vec) - 1 while i < j: vec[i].next = vec[j] i += 1 if i == j: break vec[j].next = vec[i] j -= 1 vec[i].next = None
def findMin(self, nums: List[int]) -> int: low, high = 0, len(nums) - 1 while low < high: pivot = low + (high - low) // 2 if nums[pivot] < nums[high]: high = pivot else: low = pivot + 1 return nums[low]
def findPeakElement(self, nums: List[int]) -> int: idx = 0 for i in range(1, len(nums)): if nums[i] > nums[idx]: idx = i return idx
def compareVersion(self, version1: str, version2: str) -> int: n, m = len(version1), len(version2) i, j = 0, 0 while i < n or j < m: x = 0 while i < n and version1[i] != '.': x = x * 10 + ord(version1[i]) - ord('0') i += 1 i += 1 y = 0 while j < m and version2[j] != '.': y = y * 10 + ord(version2[j]) - ord('0') j += 1 j += 1 if x != y: return 1 if x > y else -1 return 0
def fractionToDecimal(self, numerator: int, denominator: int) -> str: if numerator % denominator == 0: return str(numerator // denominator) s = [] if (numerator < 0) != (denominator < 0): s.append('-') numerator = abs(numerator) denominator = abs(denominator) integerPart = numerator // denominator s.append(str(integerPart)) s.append('.') indexMap = {} remainder = numerator % denominator while remainder and remainder not in indexMap: indexMap[remainder] = len(s) remainder *= 10 s.append(str(remainder // denominator)) remainder %= denominator if remainder: insertIndex = indexMap[remainder] s.insert(insertIndex, '(') s.append(')') return ''.join(s)
def convertToTitle(self, columnNumber: int) -> str: ans = list() while columnNumber > 0: columnNumber -= 1 ans.append(chr(columnNumber % 26 + ord("A"))) columnNumber //= 26 return "".join(ans[::-1])
def rob(self, nums: List[int]) -> int: if not nums: return 0 size = len(nums) if size == 1: return nums[0] dp = [0] * size dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, size): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[size - 1]
def rangeBitwiseAnd(self, m: int, n: int) -> int: shift = 0 while m < n: m = m >> 1 n = n >> 1 shift += 1 return m << shift
def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: edges = collections.defaultdict(list) indeg = [0] * numCourses for info in prerequisites: edges[info[1]].append(info[0]) indeg[info[0]] += 1 q = collections.deque([u for u in range(numCourses) if indeg[u] == 0]) visited = 0 while q: visited += 1 u = q.popleft() for v in edges[u]: indeg[v] -= 1 if indeg[v] == 0: q.append(v) return visited == numCourses
def maximalSquare(self, matrix: List[List[str]]) -> int: if len(matrix) == 0 or len(matrix[0]) == 0: return 0 maxSide = 0 rows, columns = len(matrix), len(matrix[0]) for i in range(rows): for j in range(columns): if matrix[i][j] == '1': maxSide = max(maxSide, 1) currentMaxSide = min(rows - i, columns - j) for k in range(1, currentMaxSide): flag = True if matrix[i + k][j + k] == '0': break for m in range(k): if matrix[i + k][j + m] == '0' or matrix[i + m][j + k] == '0': flag = False break if flag: maxSide = max(maxSide, k + 1) else: break maxSquare = maxSide * maxSide return maxSquare
def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int: area1 = (ax2 - ax1) * (ay2 - ay1) area2 = (bx2 - bx1) * (by2 - by1) overlapWidth = min(ax2, bx2) - max(ax1, bx1) overlapHeight = min(ay2, by2) - max(ay1, by1) overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0) return area1 + area2 - overlapArea
def invertTree(self, root: TreeNode) -> TreeNode: if not root: return root left = self.invertTree(root.left) right = self.invertTree(root.right) root.left, root.right = right, left return root
def calculate(self, s: str) -> int: n = len(s) stack = [] preSign = '+' num = 0 for i in range(n): if s[i] != ' ' and s[i].isdigit(): num = num * 10 + ord(s[i]) - ord('0') if i == n - 1 or s[i] in '+-*/': if preSign == '+': stack.append(num) elif preSign == '-': stack.append(-num) elif preSign == '*': stack.append(stack.pop() * num) else: stack.append(int(stack.pop() / num)) preSign = s[i] num = 0 return sum(stack)
def majorityElement(self, nums: List[int]) -> List[int]: cnt = {} ans = [] for v in nums: if v in cnt: cnt[v] += 1 else: cnt[v] = 1 for item in cnt.keys(): if cnt[item] > len(nums)//3: ans.append(item) return ans
def kthSmallest(self, root: TreeNode, k: int) -> int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right
def isPowerOfTwo(self, n: int) -> bool: return n > 0 and (n & (n - 1)) == 0
def isPalindrome(self, head: ListNode) -> bool: self.front_pointer = head def recursively_check(current_node=head): if current_node is not None: if not recursively_check(current_node.next): return False if self.front_pointer.val != current_node.val: return False self.front_pointer = self.front_pointer.next return True return recursively_check()
def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ancestor = root while True: if p.val < ancestor.val and q.val < ancestor.val: ancestor = ancestor.left elif p.val > ancestor.val and q.val > ancestor.val: ancestor = ancestor.right else: break return ancestor
def productExceptSelf(self, nums: List[int]) -> List[int]: length = len(nums) answer = [0]*length answer[0] = 1 for i in range(1, length): answer[i] = nums[i - 1] * answer[i - 1] R = 1; for i in reversed(range(length)): answer[i] = answer[i] * R R *= nums[i] return answer
def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]: n = len(nums) q = [(-nums[i], i) for i in range(k)] heapq.heapify(q) ans = [-q[0][0]] for i in range(k, n): heapq.heappush(q, (-nums[i], i)) while q[0][1] <= i - k: heapq.heappop(q) ans.append(-q[0][0]) return ans
def searchMatrix(self, matrix: List[List[int]], target: int) -> bool: for row in matrix: for element in row: if element == target: return True return False
def diffWaysToCompute(self, input: str) -> List[int]: if input.isdigit(): return [int(input)] res = [] for i, char in enumerate(input): if char in ['+', '-', '*']: left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) for l in left: for r in right: if char == '+': res.append(l + r) elif char == '-': res.append(l - r) else: res.append(l * r) return res
def binaryTreePaths(self, root: TreeNode) -> List[str]: paths = list() if not root: return paths node_queue = collections.deque([root]) path_queue = collections.deque([str(root.val)]) while node_queue: node = node_queue.popleft() path = path_queue.popleft() if not node.left and not node.right: paths.append(path) else: if node.left: node_queue.append(node.left) path_queue.append(path + '->' + str(node.left.val)) if node.right: node_queue.append(node.right) path_queue.append(path + '->' + str(node.right.val)) return paths
def singleNumber(self, nums: List[int]) -> List[int]: xorsum = 0 for num in nums: xorsum ^= num lsb = xorsum & (-xorsum) type1 = type2 = 0 for num in nums: if num & lsb: type1 ^= num else: type2 ^= num return [type1, type2]
def missingNumber(self, nums: List[int]) -> int: nums.sort() for i, num in enumerate(nums): if num != i: return i return len(nums)
def hIndex(self, citations: List[int]) -> int: sorted_citation = sorted(citations, reverse = True) h = 0; i = 0; n = len(citations) while i < n and sorted_citation[i] > h: h += 1 i += 1 return h
def moveZeroes(self, nums: List[int]) -> None: n = len(nums) left = right = 0 while right < n: if nums[right] != 0: nums[left], nums[right] = nums[right], nums[left] left += 1 right += 1
def wordPattern(self, pattern: str, s: str) -> bool: word2ch = dict() ch2word = dict() words = s.split() if len(pattern) != len(words): return False for ch, word in zip(pattern, words): if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word): return False word2ch[word] = ch ch2word[ch] = word return True
def getHint(self, secret: str, guess: str) -> str: bulls = 0 cntS, cntG = [0] * 10, [0] * 10 for s, g in zip(secret, guess): if s == g: bulls += 1 else: cntS[int(s)] += 1 cntG[int(g)] += 1 cows = sum(min(s, g) for s, g in zip(cntS, cntG)) return f'{bulls}A{cows}B'
def maxProfit(self, prices: List[int]) -> int: if not prices: return 0 n = len(prices) f = [[-prices[0], 0, 0]] + [[0] * 3 for _ in range(n - 1)] for i in range(1, n): f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i]) f[i][1] = f[i - 1][0] + prices[i] f[i][2] = max(f[i - 1][1], f[i - 1][2]) return max(f[n - 1][1], f[n - 1][2])
def maxCoins(self, nums: List[int]) -> int: n = len(nums) rec = [[0] * (n + 2) for _ in range(n + 2)] val = [1] + nums + [1] for i in range(n - 1, -1, -1): for j in range(i + 2, n + 2): for k in range(i + 1, j): total = val[i] * val[k] * val[j] total += rec[i][k] + rec[k][j] rec[i][j] = max(rec[i][j], total) return rec[0][n + 1]
def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int: dp = [0] * (n + 1) m = len(primes) pointers = [0] * m nums = [1] * m for i in range(1, n + 1): min_num = min(nums) dp[i] = min_num for j in range(m): if nums[j] == min_num: pointers[j] += 1 nums[j] = dp[pointers[j]] * primes[j] return dp[n]
def bulbSwitch(self, n: int) -> int: return int(sqrt(n + 0.5))
def isPowerOfThree(self, n: int) -> bool: while n and n % 3 == 0: n //= 3 return n == 1
def oddEvenList(self, head: ListNode) -> ListNode: if not head: return head evenHead = head.next odd, even = head, evenHead while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head
def longestIncreasingPath(self, matrix: List[List[int]]) -> int: if not matrix: return 0 rows, columns = len(matrix), len(matrix[0]) outdegrees = [[0] * columns for _ in range(rows)] queue = collections.deque() for i in range(rows): for j in range(columns): for dx, dy in Solution.DIRS: newRow, newColumn = i + dx, j + dy if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[i][j]: outdegrees[i][j] += 1 if outdegrees[i][j] == 0: queue.append((i, j)) ans = 0 while queue: ans += 1 size = len(queue) for _ in range(size): row, column = queue.popleft() for dx, dy in Solution.DIRS: newRow, newColumn = row + dx, column + dy if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] < matrix[row][column]: outdegrees[newRow][newColumn] -= 1 if outdegrees[newRow][newColumn] == 0: queue.append((newRow, newColumn)) return ans
def countBits(self, n: int) -> List[int]: bits = [0] for i in range(1, n + 1): bits.append(bits[i >> 1] + (i & 1)) return bits
def isPowerOfFour(self, n: int) -> bool: return n > 0 and (n & (n - 1)) == 0 and (n & 0xaaaaaaaa) == 0
def integerBreak(self, n: int) -> int: dp = [0] * (n + 1) for i in range(2, n + 1): for j in range(i): dp[i] = max(dp[i], j * (i - j), j * dp[i - j]) return dp[n]
def reverseVowels(self, s: str) -> str: def isVowel(ch: str) -> bool: return ch in "aeiouAEIOU" n = len(s) s = list(s) i, j = 0, n - 1 while i < j: while i < n and not isVowel(s[i]): i += 1 while j > 0 and not isVowel(s[j]): j -= 1 if i < j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return "".join(s)
def isPerfectSquare(self, num: int) -> bool: x = 1 square = 1 while square <= num: if square == num: return True x += 1 square = x * x return False
def wiggleMaxLength(self, nums: List[int]) -> int: n = len(nums) if n < 2: return n up = down = 1 for i in range(1, n): if nums[i] > nums[i - 1]: up = down + 1 elif nums[i] < nums[i - 1]: down = up + 1 return max(up, down)
def isSubsequence(self, s: str, t: str) -> bool: n, m = len(s), len(t) i = j = 0 while i < n and j < m: if s[i] == t[j]: i += 1 j += 1 return i == n
def integerReplacement(self, n: int) -> int: if n == 1: return 0 if n % 2 == 0: return 1 + self.integerReplacement(n // 2) return 2 + min(self.integerReplacement(n // 2), self.integerReplacement(n // 2 + 1))
def readBinaryWatch(self, turnedOn: int) -> List[str]: ans = list() for h in range(12): for m in range(60): if bin(h).count("1") + bin(m).count("1") == turnedOn: ans.append(f"{h}:{m:02d}") return ans
def removeKdigits(self, num: str, k: int) -> str: numStack = [] for digit in num: while k and numStack and numStack[-1] > digit: numStack.pop() k -= 1 numStack.append(digit) finalStack = numStack[:-k] if k else numStack return "".join(finalStack).lstrip('0') or "0"
def fizzBuzz(self, n: int) -> List[str]: ans = [] for i in range(1, n + 1): s = "" if i % 3 == 0: s += "Fizz" if i % 5 == 0: s += "Buzz" if s == "": s = str(i) ans.append(s) return ans
def numberOfArithmeticSlices(self, nums: List[int]) -> int: n = len(nums) if n == 1: return 0 d, t = nums[0] - nums[1], 0 ans = 0 for i in range(2, n): if nums[i - 1] - nums[i] == d: t += 1 else: d = nums[i - 1] - nums[i] t = 0 ans += t return ans
def thirdMax(self, nums: List[int]) -> int: nums.sort(reverse=True) diff = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: diff += 1 if diff == 3: return nums[i] return nums[0]
def originalDigits(self, s: str) -> str: c = Counter(s) cnt = [0] * 10 cnt[0] = c["z"] cnt[2] = c["w"] cnt[4] = c["u"] cnt[6] = c["x"] cnt[8] = c["g"] cnt[3] = c["h"] - cnt[8] cnt[5] = c["f"] - cnt[4] cnt[7] = c["s"] - cnt[6] cnt[1] = c["o"] - cnt[0] - cnt[2] - cnt[4] cnt[9] = c["i"] - cnt[5] - cnt[6] - cnt[8] return "".join(str(x) * cnt[x] for x in range(10))
def countSegments(self, s): ans = 0 for i in range(len(s)): if (i == 0 or s[i - 1] == ' ') and s[i] != ' ': ans += 1 return ans
def arrangeCoins(self, n: int) -> int: return int((pow(8 * n + 1, 0.5) - 1) / 2)
def numberOfBoomerangs(self, points: List[List[int]]) -> int: ans = 0 for p in points: cnt = defaultdict(int) for q in points: dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]) cnt[dis] += 1 for m in cnt.values(): ans += m * (m - 1) return ans
def findDisappearedNumbers(self, nums: List[int]) -> List[int]: n = len(nums) for num in nums: x = (num - 1) % n nums[x] += n ret = [i + 1 for i, num in enumerate(nums) if num <= n] return ret
def findMinArrowShots(self, points: List[List[int]]) -> int: if not points: return 0 points.sort(key=lambda balloon: balloon[1]) pos = points[0][1] ans = 1 for balloon in points: if balloon[0] > pos: pos = balloon[1] ans += 1 return ans
def minMoves(self, nums: List[int]) -> int: min_num = min(nums) res = 0 for num in nums: res += num - min_num return res
def findContentChildren(self, g: List[int], s: List[int]) -> int: g.sort() s.sort() n, m = len(g), len(s) i = j = count = 0 while i < n and j < m: while j < m and g[i] > s[j]: j += 1 if j < m: count += 1 i += 1 j += 1 return count
def circularArrayLoop(self, nums: List[int]) -> bool: n = len(nums) def next(cur: int) -> int: return (cur + nums[cur]) % n for i, num in enumerate(nums): if num == 0: continue slow, fast = i, next(i) while nums[slow] * nums[fast] > 0 and nums[slow] * nums[next(fast)] > 0: if slow == fast: if slow == next(slow): break return True slow = next(slow) fast = next(next(fast)) add = i while nums[add] * nums[next(add)] > 0: tmp = add add = next(add) nums[tmp] = 0 return False
def kmp(pattern: str) -> bool: n = len(pattern) fail = [-1] * n for i in range(1, n): j = fail[i - 1] while j != -1 and pattern[j + 1] != pattern[i]: j = fail[j] if pattern[j + 1] == pattern[i]: fail[i] = j + 1 return fail[n - 1] != -1 and n % (n - fail[n - 1] - 1) == 0
def rand10(self) -> int: while True: row = rand7() col = rand7() idx = (row - 1) * 7 + col if idx <= 40: return 1 + (idx - 1) % 10
def findRadius(self, houses: List[int], heaters: List[int]) -> int: houses.sort() heaters.sort() ans, i, j, m, n = 0, 0, 0, len(houses), len(heaters) while i < m: pre = ans ans = max(ans, abs(houses[i] - heaters[j])) while j < n - 1 and (abs(houses[i] - heaters[j]) >= abs(houses[i] - heaters[j + 1])): j += 1 ans = max(pre, abs(houses[i] - heaters[j])) i += 1 return ans
def findComplement(self, num: int) -> int: highbit = 0 for i in range(1, 30 + 1): if num >= (1 << i): highbit = i else: break mask = (1 << (highbit + 1)) - 1 return num ^ mask
def totalHammingDistance(self, nums: List[int]) -> int: n = len(nums) ans = 0 for i in range(30): c = sum(((val >> i) & 1) for val in nums) ans += c * (n - c) return ans
def findMaxConsecutiveOnes(self, nums: List[int]) -> int: maxCount = count = 0 for i, num in enumerate(nums): if num == 1: count += 1 else: maxCount = max(maxCount, count) count = 0 maxCount = max(maxCount, count) return maxCount
def constructRectangle(self, area: int) -> List[int]: w = int(sqrt(area)) while area % w: w -= 1 return [area // w, w]
def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int: ans, expired = 0, 0 for i in range(len(timeSeries)): if timeSeries[i] >= expired: ans += duration else: ans += timeSeries[i] + duration - expired expired = timeSeries[i] + duration return ans
def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: res = {} stack = [] for num in reversed(nums2): while stack and num >= stack[-1]: stack.pop() res[num] = stack[-1] if stack else -1 stack.append(num) return [res[num] for num in nums1]
def nextGreaterElements(self, nums: List[int]) -> List[int]: n = len(nums) ret = [-1] * n stk = list() for i in range(n * 2 - 1): while stk and nums[stk[-1]] < nums[i % n]: ret[stk.pop()] = nums[i % n] stk.append(i % n) return ret
def fib(self, n: int) -> int: if n < 2: return n p, q, r = 0, 0, 1 for i in range(2, n + 1): p, q = q, r r = p + q return r
def longestPalindromeSubseq(self, s: str) -> int: n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]
def countArrangement(self, n: int) -> int: f = [0] * (1 << n) f[0] = 1 for mask in range(1, 1 << n): num = bin(mask).count("1") for i in range(n): if mask & (1 << i) and (num % (i + 1) == 0 or (i + 1) % num == 0): f[mask] += f[mask ^ (1 << i)] return f[(1 << n) - 1]
def convertBST(self, root: TreeNode) -> TreeNode: def dfs(root: TreeNode): nonlocal total if root: dfs(root.right) total += root.val root.val = total dfs(root.left) total = 0 dfs(root) return root
def checkRecord(self, s: str) -> bool: absents = lates = 0 for i, c in enumerate(s): if c == "A": absents += 1 if absents >= 2: return False if c == "L": lates += 1 if lates >= 3: return False else: lates = 0 return True
def arrayPairSum(self, nums: List[int]) -> int: nums.sort() return sum(nums[::2])
def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]: m, n = len(nums), len(nums[0]) if m * n != r * c: return nums ans = [[0] * c for _ in range(r)] for x in range(m * n): ans[x // c][x % c] = nums[x // n][x % n] return ans
def findUnsortedSubarray(self, nums: List[int]) -> int: n = len(nums) maxn, right = float("-inf"), -1 minn, left = float("inf"), -1 for i in range(n): if maxn > nums[i]: right = i else: maxn = nums[i] if minn < nums[n - i - 1]: left = n - i - 1 else: minn = nums[n - i - 1] return 0 if right == -1 else right - left + 1
def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n]
def findLHS(self, nums: List[int]) -> int: nums.sort() res, begin = 0, 0 for end in range(len(nums)): while nums[end] - nums[begin] > 1: begin += 1 if nums[end] - nums[begin] == 1: res = max(res, end - begin + 1) return res
def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int: mina, minb = m, n for a, b in ops: mina = min(mina, a) minb = min(minb, b) return mina * minb
def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool: count, m, prev = 0, len(flowerbed), -1 for i in range(m): if flowerbed[i] == 1: if prev < 0: count += i // 2 else: count += (i - prev - 2) // 2 prev = i if prev < 0: count += (m + 1) // 2 else: count += (m - prev - 1) // 2 return count >= n
def triangleNumber(self, nums: List[int]) -> int: n = len(nums) nums.sort() ans = 0 for i in range(n): k = i for j in range(i + 1, n): while k + 1 < n and nums[k + 1] < nums[i] + nums[j]: k += 1 ans += max(k - j, 0) return ans
def smallestRange(self, nums: List[List[int]]) -> List[int]: n = len(nums) indices = collections.defaultdict(list) xMin, xMax = 10**9, -10**9 for i, vec in enumerate(nums): for x in vec: indices[x].append(i) xMin = min(xMin, *vec) xMax = max(xMax, *vec) freq = [0] * n inside = 0 left, right = xMin, xMin - 1 bestLeft, bestRight = xMin, xMax while right < xMax: right += 1 if right in indices: for x in indices[right]: freq[x] += 1 if freq[x] == 1: inside += 1 while inside == n: if right - left < bestRight - bestLeft: bestLeft, bestRight = left, right if left in indices: for x in indices[left]: freq[x] -= 1 if freq[x] == 0: inside -= 1 left += 1 return [bestLeft, bestRight]
def findMaxAverage(self, nums: List[int], k: int) -> float: maxTotal = total = sum(nums[:k]) n = len(nums) for i in range(k, n): total = total - nums[i - k] + nums[i] maxTotal = max(maxTotal, total) return maxTotal / k
def minSteps(self, n: int) -> int: f = [0] * (n + 1) for i in range(2, n + 1): f[i] = float("inf") j = 1 while j * j <= i: if i % j == 0: f[i] = min(f[i], f[j] + i // j) f[i] = min(f[i], f[i // j] + j) j += 1 return f[n]
def findSecondMinimumValue(self, root: TreeNode) -> int: ans, rootvalue = -1, root.val def dfs(node: TreeNode) -> None: nonlocal ans if not node: return if ans != -1 and node.val >= ans: return if node.val > rootvalue: ans = node.val dfs(node.left) dfs(node.right) dfs(root) return ans
def findNumberOfLIS(self, nums: List[int]) -> int: n, max_len, ans = len(nums), 0, 0 dp = [0] * n cnt = [0] * n for i, x in enumerate(nums): dp[i] = 1 cnt[i] = 1 for j in range(i): if x > nums[j]: if dp[j] + 1 > dp[i]: dp[i] = dp[j] + 1 cnt[i] = cnt[j] elif dp[j] + 1 == dp[i]: cnt[i] += cnt[j] if dp[i] > max_len: max_len = dp[i] ans = cnt[i] elif dp[i] == max_len: ans += cnt[i] return ans
def findLengthOfLCIS(self, nums: List[int]) -> int: ans = 0 n = len(nums) start = 0 for i in range(n): if i > 0 and nums[i] <= nums[i - 1]: start = i ans = max(ans, i - start + 1) return ans
def getImportance(self, employees: List['Employee'], idx: int) -> int: mp = {employee.id: employee for employee in employees} total = 0 que = collections.deque([idx]) while que: curIdx = que.popleft() employee = mp[curIdx] total += employee.importance for subIdx in employee.subordinates: que.append(subIdx) return total
def searchBST(self, root: TreeNode, val: int) -> TreeNode: while root: if val == root.val: return root root = root.left if val < root.val else root.right return None
def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode: if not root: return TreeNode(val) pos = root while pos: if val < pos.val: if not pos.left: pos.left = TreeNode(val) break else: pos = pos.left else: if not pos.right: pos.right = TreeNode(val) break else: pos = pos.right return root
def search(self, nums: List[int], target: int) -> int: low, high = 0, len(nums) - 1 while low <= high: mid = (high - low) // 2 + low num = nums[mid] if num == target: return mid elif num > target: high = mid - 1 else: low = mid + 1 return -1
def maxProfit(self, prices: List[int], fee: int) -> int: n = len(prices) dp = [[0, -prices[0]]] + [[0, 0] for _ in range(n - 1)] for i in range(1, n): dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]) return dp[n - 1][0]
def dailyTemperatures(self, temperatures: List[int]) -> List[int]: length = len(temperatures) ans = [0] * length stack = [] for i in range(length): temperature = temperatures[i] while stack and temperature > temperatures[stack[-1]]: prev_index = stack.pop() ans[prev_index] = i - prev_index stack.append(i) return ans
def minCostClimbingStairs(self, cost: List[int]) -> int: n = len(cost) dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[n]
def crackSafe(self, n: int, k: int) -> str: seen = set() ans = list() highest = 10 ** (n - 1) def dfs(node: int): for x in range(k): nei = node * 10 + x if nei not in seen: seen.add(nei) dfs(nei % highest) ans.append(str(x)) dfs(0) return "".join(ans) + "0" * (n - 1)
def partitionLabels(self, s: str) -> List[int]: last = [0] * 26 for i, ch in enumerate(s): last[ord(ch) - ord("a")] = i partition = list() start = end = 0 for i, ch in enumerate(s): end = max(end, last[ord(ch) - ord("a")]) if i == end: partition.append(end - start + 1) start = end + 1 return partition
def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]: n = len(arr) left, right = 0.0, 1.0 while True: mid = (left + right) / 2 i, count = -1, 0 x, y = 0, 1 for j in range(1, n): while arr[i + 1] / arr[j] < mid: i += 1 if arr[i] * y > arr[j] * x: x, y = arr[i], arr[j] count += i + 1 if count == k: return [x, y] if count < k: left = mid else: right = mid
def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]: ans = list() stk = list() def dfs(x: int): if x == len(graph) - 1: ans.append(stk[:]) return for y in graph[x]: stk.append(y) dfs(y) stk.pop() stk.append(0) dfs(0) return ans
def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]: n = len(graph) color = [0] * n def safe(x: int) -> bool: if color[x] > 0: return color[x] == 2 color[x] = 1 for y in graph[x]: if not safe(y): return False color[x] = 2 return True return [i for i in range(n) if safe(i)]
def xorGame(self, nums: List[int]) -> bool: if len(nums) % 2 == 0: return True xor = 0 for (num : nums) { xor ^= num; } return xor == 0
def largeGroupPositions(self, s: str) -> List[List[int]]: ret = list() n, num = len(s), 1 for i in range(n): if i == n - 1 or s[i] != s[i + 1]: if num >= 3: ret.append([i - num + 1, i]) num = 1 else: num += 1 return ret
def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]: n = len(image) for i in range(n): left, right = 0, n - 1 while left < right: if image[i][left] == image[i][right]: image[i][left] ^= 1 image[i][right] ^= 1 left += 1 right -= 1 if left == right: image[i][left] ^= 1 return image
def new21Game(self, n: int, k: int, maxPts: int) -> float: if k == 0: return 1.0 dp = [0.0] * (k + maxPts) for i in range(k, min(n, k + maxPts - 1) + 1): dp[i] = 1.0 for i in range(k - 1, -1, -1): for j in range(1, maxPts + 1): dp[i] += dp[i + j] / maxPts return dp[0]
def build(s: str) -> str: ret = list() for ch in s: if ch != " ret.append(ch) elif ret: ret.pop() return "".join(ret)
def countDigits(n: int) -> Tuple[int]: cnt = [0] * 10 while n: cnt[n % 10] += 1 n //= 10 return tuple(cnt)
def stoneGame(self, piles: List[int]) -> bool: length = len(piles) dp = [0] * length for i, pile in enumerate(piles): dp[i] = pile for i in range(length - 2, -1, -1): for j in range(i + 1, length): dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1]) return dp[length - 1] > 0
def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int: MOD = 10**9 + 7 dp = [[0] * (minProfit + 1) for _ in range(n + 1)] for i in range(0, n + 1): dp[i][0] = 1 for earn, members in zip(profit, group): for j in range(n, members - 1, -1): for k in range(minProfit, -1, -1): dp[j][k] = (dp[j][k] + dp[j - members][max(0, k - earn)]) % MOD; return dp[n][minProfit]
def numRescueBoats(self, people: List[int], limit: int) -> int: ans = 0 people.sort() light, heavy = 0, len(people) - 1 while light <= heavy: if people[light] + people[heavy] > limit: heavy -= 1 else: light += 1 heavy -= 1 ans += 1 return ans
def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int: if not root: return 0 if root.val > high: return self.rangeSumBST(root.left, low, high) if root.val < low: return self.rangeSumBST(root.right, low, high) return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)
def validMountainArray(self, arr: List[int]) -> bool: N = len(arr) i = 0 while i + 1 < N and arr[i] < arr[i + 1]: i += 1 if i == 0 or i == N - 1: return False while i + 1 < N and arr[i] > arr[i + 1]: i += 1 return i == N - 1
def verticalTraversal(self, root: TreeNode) -> List[List[int]]: nodes = list() def dfs(node: TreeNode, row: int, col: int) -> None: if not node: return nodes.append((col, row, node.val)) dfs(node.left, row + 1, col - 1) dfs(node.right, row + 1, col + 1) dfs(root, 0, 0) nodes.sort() ans, lastcol = list(), float("-inf") for col, row, value in nodes: if col != lastcol: lastcol = col ans.append(list()) ans[-1].append(value) return ans
def equationsPossible(self, equations: List[str]) -> bool: uf = Solution.UnionFind() for st in equations: if st[1] == "=": index1 = ord(st[0]) - ord("a") index2 = ord(st[3]) - ord("a") uf.union(index1, index2) for st in equations: if st[1] == "!": index1 = ord(st[0]) - ord("a") index2 = ord(st[3]) - ord("a") if uf.find(index1) == uf.find(index2): return False return True
def isCousins(self, root: TreeNode, x: int, y: int) -> bool: x_parent, x_depth, x_found = None, None, False y_parent, y_depth, y_found = None, None, False def dfs(node: TreeNode, depth: int, parent: TreeNode): if not node: return nonlocal x_parent, y_parent, x_depth, y_depth, x_found, y_found if node.val == x: x_parent, x_depth, x_found = parent, depth, True elif node.val == y: y_parent, y_depth, y_found = parent, depth, True if x_found and y_found: return dfs(node.left, depth + 1, node) if x_found and y_found: return dfs(node.right, depth + 1, node) dfs(root, 0, None) return x_depth == y_depth and x_parent != y_parent
def recoverFromPreorder(self, traversal: str) -> TreeNode: path, pos = list(), 0 while pos < len(traversal): level = 0 while traversal[pos] == '-': level += 1 pos += 1 value = 0 while pos < len(traversal) and traversal[pos].isdigit(): value = value * 10 + (ord(traversal[pos]) - ord('0')) pos += 1 node = TreeNode(value) if level == len(path): if path: path[-1].left = node else: path = path[:level] path[-1].right = node path.append(node) return path[0]
def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]: dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)] maxDist = max(rCenter, rows - 1 - rCenter) + max(cCenter, cols - 1 - cCenter) row, col = rCenter, cCenter ret = [[row, col]] for dist in range(1, maxDist + 1): row -= 1 for i, (dr, dc) in enumerate(dirs): while (i % 2 == 0 and row != rCenter) or (i % 2 != 0 and col != cCenter): if 0 <= row < rows and 0 <= col < cols: ret.append([row, col]) row += dr col += dc return ret
def convertBST(self, root: TreeNode) -> TreeNode: def dfs(root: TreeNode): nonlocal total if root: dfs(root.right) total += root.val root.val = total dfs(root.left) total = 0 dfs(root) return root
def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]: nums = [0] * n for left, right, inc in bookings: nums[left - 1] += inc if right < n: nums[right] -= inc for i in range(1, n): nums[i] += nums[i - 1] return nums
def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int: num = [0] * 100 ret = 0 for x, y in dominoes: val = (x * 10 + y if x <= y else y * 10 + x) ret += num[val] num[val] += 1 return ret
def tribonacci(self, n: int) -> int: if n == 0: return 0 if n <= 2: return 1 p = 0 q = r = 1 for i in range(3, n + 1): s = p + q + r p, q, r = q, r, s return s
def longestCommonSubsequence(self, text1: str, text2: str) -> int: m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]
def balancedStringSplit(self, s: str) -> int: ans, d = 0, 0 for ch in s: if ch == 'L': d += 1 else: d -= 1 if d == 0: ans += 1 return ans
def maxPower(self, s: str) -> int: ans, cnt = 1, 1 for i in range(1, len(s)): if s[i] == s[i - 1]: cnt += 1 ans = max(ans, cnt) else: cnt = 1 return ans
def sumOddLengthSubarrays(self, arr: List[int]) -> int: sum = 0 n = len(arr) for i, v in enumerate(arr): leftCount, rightCount = i, n - i - 1 leftOdd = (leftCount + 1) // 2 rightOdd = (rightCount + 1) // 2 leftEven = leftCount // 2 + 1 rightEven = rightCount // 2 + 1 sum += v * (leftOdd * rightOdd + leftEven * rightEven) return sum
def runningSum(self, nums: List[int]) -> List[int]: n = len(nums) for i in range(1, n): nums[i] += nums[i - 1] return nums
def getMaximumGenerated(self, n: int) -> int: if n == 0: return 0 nums = [0] * (n + 1) nums[1] = 1 for i in range(2, n + 1): nums[i] = nums[i // 2] + i % 2 * nums[i // 2 + 1] return max(nums)
def countDigitOne(self, n: int) -> int: k, mulk = 0, 1 ans = 0 while n >= mulk: ans += (n // (mulk * 10)) * mulk + min(max(n % (mulk * 10) - mulk + 1, 0), mulk) k += 1 mulk *= 10 return ans
def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool: diff = [0] * 52 for l, r in ranges: diff[l] += 1 diff[r+1] -= 1 curr = 0 for i in range(1, 51): curr += diff[i] if left <= i <= right and curr <= 0: return False return True
def chalkReplacer(self, chalk: List[int], k: int) -> int: total = sum(chalk) k %= total res = -1 for i, cnt in enumerate(chalk): if cnt > k: res = i break k -= cnt return res
def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]: total = list(accumulate(candiesCount)) ans = list() for favoriteType, favoriteDay, dailyCap in queries: x1 = favoriteDay + 1 y1 = (favoriteDay + 1) * dailyCap x2 = 1 if favoriteType == 0 else total[favoriteType - 1] + 1 y2 = total[favoriteType] ans.append(not(x1 > y2 or y1 < x2)) return ans
def minPairSum(self, nums: List[int]) -> int: n = len(nums) res = 0 nums.sort() for i in range(n // 2): res = max(res, nums[i] + nums[n-1-i]) return res
def kthLargestValue(self, matrix: List[List[int]], k: int) -> int: m, n = len(matrix), len(matrix[0]) pre = [[0] * (n + 1) for _ in range(m + 1)] results = list() for i in range(1, m + 1): for j in range(1, n + 1): pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1] results.append(pre[i][j]) results.sort(reverse=True) return results[k - 1]
def decode(self, encoded: List[int]) -> List[int]: n = len(encoded) + 1 total = reduce(xor, range(1, n + 1)) odd = 0 for i in range(1, n - 1, 2): odd ^= encoded[i] perm = [total ^ odd] for i in range(n - 1): perm.append(perm[-1] ^ encoded[i]) return perm
def decode(self, encoded: List[int], first: int) -> List[int]: arr = [first] for num in encoded: arr.append(arr[-1] ^ num) return arr
def maxFrequency(self, nums: List[int], k: int) -> int: nums.sort() n = len(nums) l = 0 total = 0 res = 1 for r in range(1, n): total += (nums[r] - nums[r - 1]) * (r - l) while total > k: total -= nums[r] - nums[l] l += 1 res = max(res, r - l + 1) return res
def countTriplets(self, arr: List[int]) -> int: n = len(arr) s = [0] for val in arr: s.append(s[-1] ^ val) ans = 0 for i in range(n): for k in range(i + 1, n): if s[i] == s[k + 1]: ans += k - i return ans
def minimumOperations(self, leaves: str) -> int: n = len(leaves) g = (1 if leaves[0] == "y" else -1) gmin = g ans = float("inf") for i in range(1, n): isYellow = int(leaves[i] == "y") g += 2 * isYellow - 1 if i != n - 1: ans = min(ans, gmin - g) gmin = min(gmin, g) return ans + (g + n) // 2
def xorOperation(self, n: int, start: int) -> int: ans = 0 for i in range(n): ans ^= (start + i * 2) return ans
def numWays(self, n: int, relation: List[List[int]], k: int) -> int: dp = [[0] * (n + 1) for _ in range(k + 1)] dp[0][0] = 1 for i in range(k): for edge in relation: src = edge[0] dst = edge[1] dp[i + 1][dst] += dp[i][src] return dp[k][n - 1]
def numWays(self, steps: int, arrLen: int) -> int: mod = 10**9 + 7 maxColumn = min(arrLen - 1, steps) dp = [[0] * (maxColumn + 1) for _ in range(steps + 1)] dp[0][0] = 1 for i in range(1, steps + 1): for j in range(0, maxColumn + 1): dp[i][j] = dp[i - 1][j] if j - 1 >= 0: dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod if j + 1 <= maxColumn: dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod return dp[steps][0]
def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]: xors = [0] for num in arr: xors.append(xors[-1] ^ num) ans = list() for left, right in queries: ans.append(xors[left] ^ xors[right + 1]) return ans
