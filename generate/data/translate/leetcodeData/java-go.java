public int maxPower(String s) { int ans = 1, cnt = 1; for (int i = 1; i < s.length(); ++i) { if (s.charAt(i) == s.charAt(i - 1)) { ++cnt; ans = Math.max(ans, cnt); } else { cnt = 1; } } return ans; }
public int findNthDigit(int n) { int d = 1, count = 9; while (n > (long) d * count) { n -= d * count; d++; count *= 10; } int index = n - 1; int start = (int) Math.pow(10, d - 1); int num = start + index / d; int digitIndex = index % d; int digit = (num / (int)(Math.pow(10, d - digitIndex - 1))) % 10; return digit; }
public int[] kthSmallestPrimeFraction(int[] arr, int k) { int n = arr.length; double left = 0.0, right = 1.0; while (true) { double mid = (left + right) / 2; int i = -1, count = 0; int x = 0, y = 1; for (int j = 1; j < n; ++j) { while ((double) arr[i + 1] / arr[j] < mid) { ++i; if (arr[i] * y > arr[j] * x) { x = arr[i]; y = arr[j]; } } count += i + 1; } if (count == k) { return new int[]{x, y}; } if (count < k) { left = mid; } else { right = mid; } } }
public List<Integer> findAnagrams(String s, String p) { int sLen = s.length(), pLen = p.length(); if (sLen < pLen) { return new ArrayList<Integer>(); } List<Integer> ans = new ArrayList<Integer>(); int[] sCount = new int[26]; int[] pCount = new int[26]; for (int i = 0; i < pLen; ++i) { ++sCount[s.charAt(i) - 'a']; ++pCount[p.charAt(i) - 'a']; } if (Arrays.equals(sCount, pCount)) { ans.add(0); } for (int i = 0; i < sLen - pLen; ++i) { --sCount[s.charAt(i) - 'a']; ++sCount[s.charAt(i + pLen) - 'a']; if (Arrays.equals(sCount, pCount)) { ans.add(i + 1); } } return ans; }
public int[] flip() { int x = rand.nextInt(total); int sumZero = 0; int curr = 0; total--; for (Set<Integer> bucket : buckets) { if (sumZero + bucketSize - bucket.size() > x) { for (int i = 0; i < bucketSize; ++i) { if (!bucket.contains(curr + i)) { if (sumZero == x) { bucket.add(curr + i); return new int[]{(curr + i) / n, (curr + i) % n}; } sumZero++; } } } curr += bucketSize; sumZero += bucketSize - bucket.size(); } return null; }
public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (val == root.val) { return root; } return searchBST(val < root.val ? root.left : root.right, val); }
public int poorPigs(int buckets, int minutesToDie, int minutesToTest) { int states = minutesToTest / minutesToDie + 1; return (int) Math.ceil(Math.log(buckets) / Math.log(states)); }
public int[] shuffle() { Random random = new Random(); for (int i = 0; i < nums.length; ++i) { int j = i + random.nextInt(nums.length - i); int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } return nums; }
public int maxDepth(Node root) { if (root == null) { return 0; } int maxChildDepth = 0; List<Node> children = root.children; for (Node child : children) { int childDepth = maxDepth(child); maxChildDepth = Math.max(maxChildDepth, childDepth); } return maxChildDepth + 1; }
public int findLHS(int[] nums) { Arrays.sort(nums); int begin = 0; int res = 0; for (int end = 0; end < nums.length; end++) { while (nums[end] - nums[begin] > 1) { begin++; } if (nums[end] - nums[begin] == 1) { res = Math.max(res, end - begin + 1); } } return res; }
public int integerReplacement(int n) { if (n == 1) { return 0; } if (n % 2 == 0) { return 1 + integerReplacement(n / 2); } return 2 + Math.min(integerReplacement(n / 2), integerReplacement(n / 2 + 1)); }
public int maxProduct(String[] words) { int length = words.length; int[] masks = new int[length]; for (int i = 0; i < length; i++) { String word = words[i]; int wordLength = word.length(); for (int j = 0; j < wordLength; j++) { masks[i] |= 1 << (word.charAt(j) - 'a'); } } int maxProd = 0; for (int i = 0; i < length; i++) { for (int j = i + 1; j < length; j++) { if ((masks[i] & masks[j]) == 0) { maxProd = Math.max(maxProd, words[i].length() * words[j].length()); } } } return maxProd; }
public int bulbSwitch(int n) { return (int) Math.sqrt(n + 0.5); }
public void insert(String key, int val) { int delta = val - map.getOrDefault(key, 0); map.put(key, val); TrieNode node = root; for (char c : key.toCharArray()) { if (node.next[c - 'a'] == null) { node.next[c - 'a'] = new TrieNode(); } node = node.next[c - 'a']; node.val += delta; } }
public boolean detectCapitalUse(String word) { if (word.length() >= 2 && Character.isLowerCase(word.charAt(0)) && Character.isUpperCase(word.charAt(1))) { return false; } for (int i = 2; i < word.length(); ++i) { if (Character.isLowerCase(word.charAt(i)) ^ Character.isLowerCase(word.charAt(1))) { return false; } } return true; }
public int getMoneyAmount(int n) { int[][] f = new int[n + 1][n + 1]; for (int i = n - 1; i >= 1; i--) { for (int j = i + 1; j <= n; j++) { f[i][j] = j + f[i][j - 1]; for (int k = i; k < j; k++) { f[i][j] = Math.min(f[i][j], k + Math.max(f[i][k - 1], f[k + 1][j])); } } } return f[1][n]; }
public int findPoisonedDuration(int[] timeSeries, int duration) { int ans = 0; int expired = 0; for (int i = 0; i < timeSeries.length; ++i) { if (timeSeries[i] >= expired) { ans += duration; } else { ans += timeSeries[i] + duration - expired; } expired = timeSeries[i] + duration; } return ans; }
public boolean buddyStrings(String s, String goal) { if (s.length() != goal.length()) { return false; } if (s.equals(goal)) { int[] count = new int[26]; for (int i = 0; i < s.length(); i++) { count[s.charAt(i) - 'a']++; if (count[s.charAt(i) - 'a'] > 1) { return true; } } return false; } else { int first = -1, second = -1; for (int i = 0; i < goal.length(); i++) { if (s.charAt(i) != goal.charAt(i)) { if (first == -1) first = i; else if (second == -1) second = i; else return false; } } return (second != -1 && s.charAt(first) == goal.charAt(second) && s.charAt(second) == goal.charAt(first)); } }
public String getHint(String secret, String guess) { int bulls = 0; int[] cntS = new int[10]; int[] cntG = new int[10]; for (int i = 0; i < secret.length(); ++i) { if (secret.charAt(i) == guess.charAt(i)) { ++bulls; } else { ++cntS[secret.charAt(i) - '0']; ++cntG[guess.charAt(i) - '0']; } } int cows = 0; for (int i = 0; i < 10; ++i) { cows += Math.min(cntS[i], cntG[i]); } return Integer.toString(bulls) + "A" + Integer.toString(cows) + "B"; }
public int maxCount(int m, int n, int[][] ops) { int mina = m, minb = n; for (int[] op : ops) { mina = Math.min(mina, op[0]); minb = Math.min(minb, op[1]); } return mina * minb; }
public int missingNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; for (int i = 0; i < n; i++) { if (nums[i] != i) { return i; } } return n; }
public int longestSubsequence(int[] arr, int difference) { int ans = 0; Map<Integer, Integer> dp = new HashMap<Integer, Integer>(); for (int v : arr) { dp.put(v, dp.getOrDefault(v - difference, 0) + 1); ans = Math.max(ans, dp.get(v)); } return ans; }
public boolean isPerfectSquare(int num) { int x = (int) Math.sqrt(num); return x * x == num; }
public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; }
public List<String> removeInvalidParentheses(String s) { List<String> ans = new ArrayList<String>(); Set<String> currSet = new HashSet<String>(); currSet.add(s); while (true) { for (String str : currSet) { if (isValid(str)) { ans.add(str); } } if (ans.size() > 0) { return ans; } Set<String> nextSet = new HashSet<String>(); for (String str : currSet) { for (int i = 0; i < str.length(); i ++) { if (i > 0 && str.charAt(i) == str.charAt(i - 1)) { continue; } if (str.charAt(i) == '(' || str.charAt(i) == ')') { nextSet.add(str.substring(0, i) + str.substring(i + 1)); } } } currSet = nextSet; } }
public int[] nextGreaterElement(int[] nums1, int[] nums2) { Map<Integer, Integer> map = new HashMap<Integer, Integer>(); Deque<Integer> stack = new ArrayDeque<Integer>(); for (int i = nums2.length - 1; i >= 0; --i) { int num = nums2[i]; while (!stack.isEmpty() && num >= stack.peek()) { stack.pop(); } map.put(num, stack.isEmpty() ? -1 : stack.peek()); stack.push(num); } int[] res = new int[nums1.length]; for (int i = 0; i < nums1.length; ++i) { res[i] = map.get(nums1[i]); } return res; }
public boolean searchMatrix(int[][] matrix, int target) { for (int[] row : matrix) { for (int element : row) { if (element == target) { return true; } } } return false; }
public int[] constructRectangle(int area) { int w = (int) Math.sqrt(area); while (area % w != 0) { --w; } return new int[]{area / w, w}; }
public int[] plusOne(int[] digits) { int n = digits.length; for (int i = n - 1; i >= 0; --i) { if (digits[i] != 9) { ++digits[i]; for (int j = i + 1; j < n; ++j) { digits[j] = 0; } return digits; } } int[] ans = new int[n + 1]; ans[0] = 1; return ans; }
public int minMoves(int[] nums) { int minNum = Arrays.stream(nums).min().getAsInt(); int res = 0; for (int num : nums) { res += num - minNum; } return res; }
public int findComplement(int num) { int highbit = 0; for (int i = 1; i <= 30; ++i) { if (num >= 1 << i) { highbit = i; } else { break; } } int mask = highbit == 30 ? 0x7fffffff : (1 << (highbit + 1)) - 1; return num ^ mask; }
public int bitwiseComplement(int n) { int highbit = 0; for (int i = 1; i <= 30; ++i) { if (n >= 1 << i) { highbit = i; } else { break; } } int mask = highbit == 30 ? 0x7fffffff : (1 << (highbit + 1)) - 1; return n ^ mask; }
public int kthSmallest(TreeNode root, int k) { Deque<TreeNode> stack = new ArrayDeque<TreeNode>(); while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); --k; if (k == 0) { break; } root = root.right; } return root.val; }
public String countAndSay(int n) { String str = "1"; for (int i = 2; i <= n; ++i) { StringBuilder sb = new StringBuilder(); int start = 0; int pos = 0; while (pos < str.length()) { while (pos < str.length() && str.charAt(pos) == str.charAt(start)) { pos++; } sb.append(Integer.toString(pos - start)).append(str.charAt(start)); start = pos; } str = sb.toString(); } return str; }
public List<String> fizzBuzz(int n) { List<String> answer = new ArrayList<String>(); for (int i = 1; i <= n; i++) { StringBuffer sb = new StringBuffer(); if (i % 3 == 0) { sb.append("Fizz"); } if (i % 5 == 0) { sb.append("Buzz"); } if (sb.length() == 0) { sb.append(i); } answer.add(sb.toString()); } return answer; }
public int arrangeCoins(int n) { return (int) ((Math.sqrt((long) 8 * n + 1) - 1) / 2); }
public List<String> findRepeatedDnaSequences(String s) { List<String> ans = new ArrayList<String>(); Map<String, Integer> cnt = new HashMap<String, Integer>(); int n = s.length(); for (int i = 0; i <= n - L; ++i) { String sub = s.substring(i, i + L); cnt.put(sub, cnt.getOrDefault(sub, 0) + 1); if (cnt.get(sub) == 2) { ans.add(sub); } } return ans; }
public int countSegments(String s) { int segmentCount = 0; for (int i = 0; i < s.length(); i++) { if ((i == 0 || s.charAt(i - 1) == ' ') && s.charAt(i) != ' ') { segmentCount++; } } return segmentCount; }
public int thirdMax(int[] nums) { long a = Long.MIN_VALUE, b = Long.MIN_VALUE, c = Long.MIN_VALUE; for (long num : nums) { if (num > a) { c = b; b = a; a = num; } else if (a > num && num > b) { c = b; b = num; } else if (b > num && num > c) { c = num; } } return c == Long.MIN_VALUE ? (int) a : (int) c; }
public String toHex(int num) { if (num == 0) { return "0"; } StringBuffer sb = new StringBuffer(); for (int i = 7; i >= 0; i --) { int val = (num >> (4 * i)) & 0xf; if (sb.length() > 0 || val > 0) { char digit = val < 10 ? (char) ('0' + val) : (char) ('a' + val - 10); sb.append(digit); } } return sb.toString(); }
public String destCity(List<List<String>> paths) { Set<String> citiesA = new HashSet<String>(); for (List<String> path : paths) { citiesA.add(path.get(0)); } for (List<String> path : paths) { if (!citiesA.contains(path.get(1))) { return path.get(1); } } return ""; }
public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int area1 = (ax2 - ax1) * (ay2 - ay1), area2 = (bx2 - bx1) * (by2 - by1); int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1), overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1); int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0); return area1 + area2 - overlapArea; }
public int findMinMoves(int[] machines) { int tot = Arrays.stream(machines).sum(); int n = machines.length; if (tot % n != 0) { return -1; } int avg = tot / n; int ans = 0, sum = 0; for (int num : machines) { num -= avg; sum += num; ans = Math.max(ans, Math.max(Math.abs(sum), num)); } return ans; }
public int pathSum(TreeNode root, int targetSum) { if (root == null) { return 0; } int ret = rootSum(root, targetSum); ret += pathSum(root.left, targetSum); ret += pathSum(root.right, targetSum); return ret; }
public int getSum(int a, int b) { while (b != 0) { int carry = (a & b) << 1; a = a ^ b; b = carry; } return a; }
public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { char c1 = word1.charAt(i - 1); for (int j = 1; j <= n; j++) { char c2 = word2.charAt(j - 1); if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } int lcs = dp[m][n]; return m - lcs + n - lcs; }
public Node dfs(Node node) { Node cur = node; Node last = null; while (cur != null) { Node next = cur.next; if (cur.child != null) { Node childLast = dfs(cur.child); next = cur.next; cur.next = cur.child; cur.child.prev = cur; if (next != null) { childLast.next = next; next.prev = childLast; } cur.child = null; last = childLast; } else { last = cur; } cur = next; } return last; }
public boolean isPowerOfThree(int n) { while (n != 0 && n % 3 == 0) { n /= 3; } return n == 1; }
public ListNode[] splitListToParts(ListNode head, int k) { int n = 0; ListNode temp = head; while (temp != null) { n++; temp = temp.next; } int quotient = n / k, remainder = n % k; ListNode[] parts = new ListNode[k]; ListNode curr = head; for (int i = 0; i < k && curr != null; i++) { parts[i] = curr; int partSize = quotient + (i < remainder ? 1 : 0); for (int j = 1; j < partSize; j++) { curr = curr.next; } ListNode next = curr.next; curr.next = null; curr = next; } return parts; }
public int lengthOfLastWord(String s) { int index = s.length() - 1; while (s.charAt(index) == ' ') { index--; } int wordLength = 0; while (index >= 0 && s.charAt(index) != ' ') { wordLength++; index--; } return wordLength; }
public int findNumberOfLIS(int[] nums) { int n = nums.length, maxLen = 0, ans = 0; int[] dp = new int[n]; int[] cnt = new int[n]; for (int i = 0; i < n; ++i) { dp[i] = 1; cnt[i] = 1; for (int j = 0; j < i; ++j) { if (nums[i] > nums[j]) { if (dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1; cnt[i] = cnt[j]; } else if (dp[j] + 1 == dp[i]) { cnt[i] += cnt[j]; } } } if (dp[i] > maxLen) { maxLen = dp[i]; ans = cnt[i]; } else if (dp[i] == maxLen) { ans += cnt[i]; } } return ans; }
public int minSteps(int n) { int[] f = new int[n + 1]; for (int i = 2; i <= n; ++i) { f[i] = Integer.MAX_VALUE; for (int j = 1; j * j <= i; ++j) { if (i % j == 0) { f[i] = Math.min(f[i], f[j] + i / j); f[i] = Math.min(f[i], f[i / j] + j); } } } return f[n]; }
public boolean canWinNim(int n) { return n % 4 != 0; }
public boolean isValidSudoku(char[][] board) { int[][] rows = new int[9][9]; int[][] columns = new int[9][9]; int[][][] subboxes = new int[3][3][9]; for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { char c = board[i][j]; if (c != '.') { int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; subboxes[i / 3][j / 3][index]++; if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) { return false; } } } } return true; }
public int findPeakElement(int[] nums) { int idx = 0; for (int i = 1; i < nums.length; ++i) { if (nums[i] > nums[idx]) { idx = i; } } return idx; }
public int numberOfBoomerangs(int[][] points) { int ans = 0; for (int[] p : points) { Map<Integer, Integer> cnt = new HashMap<Integer, Integer>(); for (int[] q : points) { int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]); cnt.put(dis, cnt.getOrDefault(dis, 0) + 1); } for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) { int m = entry.getValue(); ans += m * (m - 1); } } return ans; }
public boolean checkValidString(String s) { int minCount = 0, maxCount = 0; int n = s.length(); for (int i = 0; i < n; i++) { char c = s.charAt(i); if (c == '(') { minCount++; maxCount++; } else if (c == ')') { minCount = Math.max(minCount - 1, 0); maxCount--; if (maxCount < 0) { return false; } } else { minCount = Math.max(minCount - 1, 0); maxCount++; } } return minCount == 0; }
public int findIntegers(int n) { int[] dp = new int[31]; dp[0] = dp[1] = 1; for (int i = 2; i < 31; ++i) { dp[i] = dp[i - 1] + dp[i - 2]; } int pre = 0, res = 0; for (int i = 29; i >= 0; --i) { int val = 1 << i; if ((n & val) != 0) { res += dp[i + 1]; if (pre == 1) { break; } pre = 1; } else { pre = 0; } if (i == 0) { ++res; } } return res; }
public int search(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low <= high) { int mid = (high - low) / 2 + low; int num = nums[mid]; if (num == target) { return mid; } else if (num > target) { high = mid - 1; } else { low = mid + 1; } } return -1; }
public int rand10() { int row, col, idx; do { row = rand7(); col = rand7(); idx = col + (row - 1) * 7; } while (idx > 40); return 1 + (idx - 1) % 10; }
public int compareVersion(String version1, String version2) { String[] v1 = version1.split("\\."); String[] v2 = version2.split("\\."); for (int i = 0; i < v1.length || i < v2.length; ++i) { int x = 0, y = 0; if (i < v1.length) { x = Integer.parseInt(v1[i]); } if (i < v2.length) { y = Integer.parseInt(v2[i]); } if (x > y) { return 1; } if (x < y) { return -1; } } return 0; }
public int[] corpFlightBookings(int[][] bookings, int n) { int[] nums = new int[n]; for (int[] booking : bookings) { nums[booking[0] - 1] += booking[2]; if (booking[1] < n) { nums[booking[1]] -= booking[2]; } } for (int i = 1; i < n; i++) { nums[i] += nums[i - 1]; } return nums; }
public int sumOddLengthSubarrays(int[] arr) { int sum = 0; int n = arr.length; for (int start = 0; start < n; start++) { for (int length = 1; start + length <= n; length += 2) { int end = start + length - 1; for (int i = start; i <= end; i++) { sum += arr[i]; } } } return sum; }
public int balancedStringSplit(String s) { int ans = 0, d = 0; for (int i = 0; i < s.length(); ++i) { char ch = s.charAt(i); if (ch == 'L') { ++d; } else { --d; } if (d == 0) { ++ans; } } return ans; }
public int[] runningSum(int[] nums) { int n = nums.length; for (int i = 1; i < n; i++) { nums[i] += nums[i - 1]; } return nums; }
public void addNum(int num) { if (queMin.isEmpty() || num <= queMin.peek()) { queMin.offer(num); if (queMax.size() + 1 < queMin.size()) { queMax.offer(queMin.poll()); } } else { queMax.offer(num); if (queMax.size() > queMin.size()) { queMin.offer(queMax.poll()); } } }
public int numRescueBoats(int[] people, int limit) { int ans = 0; Arrays.sort(people); int light = 0, heavy = people.length - 1; while (light <= heavy) { if (people[light] + people[heavy] <= limit) { ++light; } --heavy; ++ans; } return ans; }
public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) { final int INF = 10000 * 101 + 1; int[] f = new int[n]; Arrays.fill(f, INF); f[src] = 0; int ans = INF; for (int t = 1; t <= k + 1; ++t) { int[] g = new int[n]; Arrays.fill(g, INF); for (int[] flight : flights) { int j = flight[0], i = flight[1], cost = flight[2]; g[i] = Math.min(g[i], f[j] + cost); } f = g; ans = Math.min(ans, f[dst]); } return ans == INF ? -1 : ans; }
public int getMaximumGenerated(int n) { if (n == 0) { return 0; } int[] nums = new int[n + 1]; nums[1] = 1; for (int i = 2; i <= n; ++i) { nums[i] = nums[i / 2] + i % 2 * nums[i / 2 + 1]; } return Arrays.stream(nums).max().getAsInt(); }
public boolean escapeGhosts(int[][] ghosts, int[] target) { int[] source = {0, 0}; int distance = manhattanDistance(source, target); for (int[] ghost : ghosts) { int ghostDistance = manhattanDistance(ghost, target); if (ghostDistance <= distance) { return false; } } return true; }
public int compress(char[] chars) { int n = chars.length; int write = 0, left = 0; for (int read = 0; read < n; read++) { if (read == n - 1 || chars[read] != chars[read + 1]) { chars[write++] = chars[read]; int num = read - left + 1; if (num > 1) { int anchor = write; while (num > 0) { chars[write++] = (char) (num % 10 + '0'); num /= 10; } reverse(chars, anchor, write - 1); } left = read + 1; } } return write; }
public String reverseStr(String s, int k) { int n = s.length(); char[] arr = s.toCharArray(); for (int i = 0; i < n; i += 2 * k) { reverse(arr, i, Math.min(i + k, n) - 1); } return new String(arr); }
public String reverseVowels(String s) { int n = s.length(); char[] arr = s.toCharArray(); int i = 0, j = n - 1; while (i < j) { while (i < n && !isVowel(arr[i])) { ++i; } while (j > 0 && !isVowel(arr[j])) { --j; } if (i < j) { swap(arr, i, j); ++i; --j; } } return new String(arr); }
public int checkRecord(int n) { final int MOD = 1000000007; int[][][] dp = new int[n + 1][2][3]; dp[0][0][0] = 1; for (int i = 1; i <= n; i++) { for (int j = 0; j <= 1; j++) { for (int k = 0; k <= 2; k++) { dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD; } } for (int k = 0; k <= 2; k++) { dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD; } for (int j = 0; j <= 1; j++) { for (int k = 1; k <= 2; k++) { dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD; } } } int sum = 0; for (int j = 0; j <= 1; j++) { for (int k = 0; k <= 2; k++) { sum = (sum + dp[n][j][k]) % MOD; } } return sum; }
public boolean checkRecord(String s) { int absents = 0, lates = 0; int n = s.length(); for (int i = 0; i < n; i++) { char c = s.charAt(i); if (c == 'A') { absents++; if (absents >= 2) { return false; } } if (c == 'L') { lates++; if (lates >= 3) { return false; } } else { lates = 0; } } return true; }
public int countArrangement(int n) { int[] f = new int[1 << n]; f[0] = 1; for (int mask = 1; mask < (1 << n); mask++) { int num = Integer.bitCount(mask); for (int i = 0; i < n; i++) { if ((mask & (1 << i)) != 0 && ((num % (i + 1)) == 0 || (i + 1) % num == 0)) { f[mask] += f[mask ^ (1 << i)]; } } } return f[(1 << n) - 1]; }
public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { final int MOD = 1000000007; int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int outCounts = 0; int[][] dp = new int[m][n]; dp[startRow][startColumn] = 1; for (int i = 0; i < maxMove; i++) { int[][] dpNew = new int[m][n]; for (int j = 0; j < m; j++) { for (int k = 0; k < n; k++) { int count = dp[j][k]; if (count > 0) { for (int[] direction : directions) { int j1 = j + direction[0], k1 = k + direction[1]; if (j1 >= 0 && j1 < m && k1 >= 0 && k1 < n) { dpNew[j1][k1] = (dpNew[j1][k1] + count) % MOD; } else { outCounts = (outCounts + count) % MOD; } } } } } dp = dpNew; } return outCounts; }
public int countDigitOne(int n) { long mulk = 1; int ans = 0; for (int k = 0; n >= mulk; ++k) { ans += (n / (mulk * 10)) * mulk + Math.min(Math.max(n % (mulk * 10) - mulk + 1, 0), mulk); mulk *= 10; } return ans; }
public int longestPalindromeSubseq(String s) { int n = s.length(); int[][] dp = new int[n][n]; for (int i = n - 1; i >= 0; i--) { dp[i][i] = 1; char c1 = s.charAt(i); for (int j = i + 1; j < n; j++) { char c2 = s.charAt(j); if (c1 == c2) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][n - 1]; }
public int nthSuperUglyNumber(int n, int[] primes) { int[] dp = new int[n + 1]; int m = primes.length; int[] pointers = new int[m]; int[] nums = new int[m]; Arrays.fill(nums, 1); for (int i = 1; i <= n; i++) { int minNum = Arrays.stream(nums).min().getAsInt(); dp[i] = minNum; for (int j = 0; j < m; j++) { if (nums[j] == minNum) { pointers[j]++; nums[j] = dp[pointers[j]] * primes[j]; } } } return dp[n]; }
public int tribonacci(int n) { if (n == 0) { return 0; } if (n <= 2) { return 1; } int p = 0, q = 0, r = 1, s = 1; for (int i = 3; i <= n; ++i) { p = q; q = r; r = s; s = p + q + r; } return s; }
public int shortestPathLength(int[][] graph) { int n = graph.length; Queue<int[]> queue = new LinkedList<int[]>(); boolean[][] seen = new boolean[n][1 << n]; for (int i = 0; i < n; ++i) { queue.offer(new int[]{i, 1 << i, 0}); seen[i][1 << i] = true; } int ans = 0; while (!queue.isEmpty()) { int[] tuple = queue.poll(); int u = tuple[0], mask = tuple[1], dist = tuple[2]; if (mask == (1 << n) - 1) { ans = dist; break; } for (int v : graph[u]) { int maskV = mask | (1 << v); if (!seen[v][maskV]) { queue.offer(new int[]{v, maskV, dist + 1}); seen[v][maskV] = true; } } } return ans; }
public int triangleNumber(int[] nums) { int n = nums.length; Arrays.sort(nums); int ans = 0; for (int i = 0; i < n; ++i) { int k = i; for (int j = i + 1; j < n; ++j) { while (k + 1 < n && nums[k + 1] < nums[i] + nums[j]) { ++k; } ans += Math.max(k - j, 0); } } return ans; }
public int findUnsortedSubarray(int[] nums) { if (isSorted(nums)) { return 0; } int[] numsSorted = new int[nums.length]; System.arraycopy(nums, 0, numsSorted, 0, nums.length); Arrays.sort(numsSorted); int left = 0; while (nums[left] == numsSorted[left]) { left++; } int right = nums.length - 1; while (nums[right] == numsSorted[right]) { right--; } return right - left + 1; }
public List<Integer> pathInZigZagTree(int label) { int row = 1, rowStart = 1; while (rowStart * 2 <= label) { row++; rowStart *= 2; } if (row % 2 == 0) { label = getReverse(label, row); } List<Integer> path = new ArrayList<Integer>(); while (row > 0) { if (row % 2 == 0) { path.add(getReverse(label, row)); } else { path.add(label); } row--; label >>= 1; } Collections.reverse(path); return path; }
public int minOperations(int[] target, int[] arr) { int n = target.length; Map<Integer, Integer> pos = new HashMap<Integer, Integer>(); for (int i = 0; i < n; ++i) { pos.put(target[i], i); } List<Integer> d = new ArrayList<Integer>(); for (int val : arr) { if (pos.containsKey(val)) { int idx = pos.get(val); int it = binarySearch(d, idx); if (it != d.size()) { d.set(it, idx); } else { d.add(idx); } } } return n - d.size(); }
public String maximumTime(String time) { char[] arr = time.toCharArray(); if (arr[0] == '?') { arr[0] = ('4' <= arr[1] && arr[1] <= '9') ? '1' : '2'; } if (arr[1] == '?') { arr[1] = (arr[0] == '2') ? '3' : '9'; } if (arr[3] == '?') { arr[3] = '5'; } if (arr[4] == '?') { arr[4] = '9'; } return new String(arr); }
public Node copyRandomList(Node head) { if (head == null) { return null; } for (Node node = head; node != null; node = node.next.next) { Node nodeNew = new Node(node.val); nodeNew.next = node.next; node.next = nodeNew; } for (Node node = head; node != null; node = node.next.next) { Node nodeNew = node.next; nodeNew.random = (node.random != null) ? node.random.next : null; } Node headNew = head.next; for (Node node = head; node != null; node = node.next) { Node nodeNew = node.next; node.next = node.next.next; nodeNew.next = (nodeNew.next != null) ? nodeNew.next.next : null; } return headNew; }
public int minAbsoluteSumDiff(int[] nums1, int[] nums2) { final int MOD = 1000000007; int n = nums1.length; int[] rec = new int[n]; System.arraycopy(nums1, 0, rec, 0, n); Arrays.sort(rec); int sum = 0, maxn = 0; for (int i = 0; i < n; i++) { int diff = Math.abs(nums1[i] - nums2[i]); sum = (sum + diff) % MOD; int j = binarySearch(rec, nums2[i]); if (j < n) { maxn = Math.max(maxn, diff - (rec[j] - nums2[i])); } if (j > 0) { maxn = Math.max(maxn, diff - (nums2[i] - rec[j - 1])); } } return (sum - maxn + MOD) % MOD; }
public int hIndex(int[] citations) { Arrays.sort(citations); int h = 0, i = citations.length - 1; while (i >= 0 && citations[i] > h) { h++; i--; } return h; }
public int numSubarraysWithSum(vector<int>& nums, int goal) { int sum = 0; unordered_map<int, int> cnt; int ret = 0; for (auto& num : nums) { cnt[sum]++; sum += num; ret += cnt[sum - goal]; } return ret; }
public int countPairs(int[] deliciousness) { final int MOD = 1000000007; int maxVal = 0; for (int val : deliciousness) { maxVal = Math.max(maxVal, val); } int maxSum = maxVal * 2; int pairs = 0; Map<Integer, Integer> map = new HashMap<Integer, Integer>(); int n = deliciousness.length; for (int i = 0; i < n; i++) { int val = deliciousness[i]; for (int sum = 1; sum <= maxSum; sum <<= 1) { int count = map.getOrDefault(sum - val, 0); pairs = (pairs + count) % MOD; } map.put(val, map.getOrDefault(val, 0) + 1); } return pairs; }
public int[] findErrorNums(int[] nums) { int[] errorNums = new int[2]; int n = nums.length; Arrays.sort(nums); int prev = 0; for (int i = 0; i < n; i++) { int curr = nums[i]; if (curr == prev) { errorNums[0] = prev; } else if (curr - prev > 1) { errorNums[1] = prev + 1; } prev = curr; } if (nums[n - 1] != n) { errorNums[1] = n; } return errorNums; }
public int maxIceCream(int[] costs, int coins) { Arrays.sort(costs); int count = 0; int n = costs.length; for (int i = 0; i < n; i++) { int cost = costs[i]; if (coins >= cost) { coins -= cost; count++; } else { break; } } return count; }
public String convertToTitle(int columnNumber) { StringBuffer sb = new StringBuffer(); while (columnNumber > 0) { int a0 = (columnNumber - 1) % 26 + 1; sb.append((char)(a0 - 1 + 'A')); columnNumber = (columnNumber - a0) / 26; } return sb.reverse().toString(); }
public int titleToNumber(String columnTitle) { int number = 0; int multiple = 1; for (int i = columnTitle.length() - 1; i >= 0; i--) { int k = columnTitle.charAt(i) - 'A' + 1; number += k * multiple; multiple *= 26; } return number; }
public int snakesAndLadders(int[][] board) { int n = board.length; boolean[] vis = new boolean[n * n + 1]; Queue<int[]> queue = new LinkedList<int[]>(); queue.offer(new int[]{1, 0}); while (!queue.isEmpty()) { int[] p = queue.poll(); for (int i = 1; i <= 6; ++i) { int nxt = p[0] + i; if (nxt > n * n) { break; } int[] rc = id2rc(nxt, n); if (board[rc[0]][rc[1]] > 0) { nxt = board[rc[0]][rc[1]]; } if (nxt == n * n) { return p[1] + 1; } if (!vis[nxt]) { vis[nxt] = true; queue.offer(new int[]{nxt, p[1] + 1}); } } } return -1; }
public List<String> readBinaryWatch(int turnedOn) { List<String> ans = new ArrayList<String>(); for (int h = 0; h < 12; ++h) { for (int m = 0; m < 60; ++m) { if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) { ans.add(h + ":" + (m < 10 ? "0" : "") + m); } } } return ans; }
public String smallestGoodBase(String n) { long nVal = Long.parseLong(n); int mMax = (int) Math.floor(Math.log(nVal) / Math.log(2)); for (int m = mMax; m > 1; m--) { int k = (int) Math.pow(nVal, 1.0 / m); long mul = 1, sum = 1; for (int i = 0; i < m; i++) { mul *= k; sum += mul; } if (sum == nVal) { return Integer.toString(k); } } return Long.toString(nVal - 1); }
public int peakIndexInMountainArray(int[] arr) { int n = arr.length; int ans = -1; for (int i = 1; i < n - 1; ++i) { if (arr[i] > arr[i + 1]) { ans = i; break; } } return ans; }
public boolean isCovered(int[][] ranges, int left, int right) { int[] diff = new int[52]; for (int[] range : ranges) { ++diff[range[0]]; --diff[range[1] + 1]; } int curr = 0; for (int i = 1; i <= 50; ++i) { curr += diff[i]; if (i >= left && i <= right && curr <= 0) { return false; } } return true; }
public int chalkReplacer(int[] chalk, int k) { int n = chalk.length; if (chalk[0] > k) { return 0; } for (int i = 1; i < n; ++i) { chalk[i] += chalk[i - 1]; if (chalk[i] > k) { return i; } } k %= chalk[n - 1]; return binarySearch(chalk, k); }
public String largestNumber(int[] cost, int target) { int[] dp = new int[target + 1]; Arrays.fill(dp, Integer.MIN_VALUE); dp[0] = 0; for (int c : cost) { for (int j = c; j <= target; ++j) { dp[j] = Math.max(dp[j], dp[j - c] + 1); } } if (dp[target] < 0) { return "0"; } StringBuffer sb = new StringBuffer(); for (int i = 8, j = target; i >= 0; i--) { for (int c = cost[i]; j >= c && dp[j] == dp[j - c] + 1; j -= c) { sb.append(i + 1); } } return sb.toString(); }
public int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int i = coin; i <= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; }
public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) { int[][] dp = new int[n + 1][minProfit + 1]; for (int i = 0; i <= n; i++) { dp[i][0] = 1; } int len = group.length, MOD = (int)1e9 + 7; for (int i = 1; i <= len; i++) { int members = group[i - 1], earn = profit[i - 1]; for (int j = n; j >= members; j--) { for (int k = minProfit; k >= 0; k--) { dp[j][k] = (dp[j][k] + dp[j - members][Math.max(0, k - earn)]) % MOD; } } } return dp[n][minProfit]; }
public int lastStoneWeightII(int[] stones) { int sum = 0; for (int weight : stones) { sum += weight; } int m = sum / 2; boolean[] dp = new boolean[m + 1]; dp[0] = true; for (int weight : stones) { for (int j = m; j >= weight; --j) { dp[j] = dp[j] || dp[j - weight]; } } for (int j = m;; --j) { if (dp[j]) { return sum - 2 * j; } } }
public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int num : nums) { sum += num; } int diff = sum - target; if (diff < 0 || diff % 2 != 0) { return 0; } int neg = diff / 2; int[] dp = new int[neg + 1]; dp[0] = 1; for (int num : nums) { for (int j = neg; j >= num; j--) { dp[j] += dp[j - num]; } } return dp[neg]; }
public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; int length = strs.length; for (int i = 0; i < length; i++) { int[] zerosOnes = getZerosOnes(strs[i]); int zeros = zerosOnes[0], ones = zerosOnes[1]; for (int j = m; j >= zeros; j--) { for (int k = n; k >= ones; k--) { dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1); } } } return dp[m][n]; }
public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } head.next = removeElements(head.next, val); return head.val == val ? head.next : head; }
public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; }
public int findMaxLength(int[] nums) { int maxLength = 0; Map<Integer, Integer> map = new HashMap<Integer, Integer>(); int counter = 0; map.put(counter, -1); int n = nums.length; for (int i = 0; i < n; i++) { int num = nums[i]; if (num == 1) { counter++; } else { counter--; } if (map.containsKey(counter)) { int prevIndex = map.get(counter); maxLength = Math.max(maxLength, i - prevIndex); } else { map.put(counter, i); } } return maxLength; }
public boolean checkSubarraySum(int[] nums, int k) { int m = nums.length; if (m < 2) { return false; } Map<Integer, Integer> map = new HashMap<Integer, Integer>(); map.put(0, -1); int remainder = 0; for (int i = 0; i < m; i++) { remainder = (remainder + nums[i]) % k; if (map.containsKey(remainder)) { int prevIndex = map.get(remainder); if (i - prevIndex >= 2) { return true; } } else { map.put(remainder, i); } } return false; }
public boolean[] canEat(int[] candiesCount, int[][] queries) { int n = candiesCount.length; long[] sum = new long[n]; sum[0] = candiesCount[0]; for (int i = 1; i < n; ++i) { sum[i] = sum[i - 1] + candiesCount[i]; } int q = queries.length; boolean[] ans = new boolean[q]; for (int i = 0; i < q; ++i) { int[] query = queries[i]; int favoriteType = query[0], favoriteDay = query[1], dailyCap = query[2]; long x1 = favoriteDay + 1; long y1 = (long) (favoriteDay + 1) * dailyCap; long x2 = favoriteType == 0 ? 1 : sum[favoriteType - 1] + 1; long y2 = sum[favoriteType]; ans[i] = !(x1 > y2 || y1 < x2); } return ans; }
public int minPairSum(int[] nums) { int n = nums.length; int res = 0; Arrays.sort(nums); for (int i = 0; i < n / 2; ++i) { res = Math.max(res, nums[i] + nums[n - 1 - i]); } return res; }
public boolean isPowerOfFour(int n) { return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0; }
public int numSubmatrixSumTarget(int[][] matrix, int target) { int ans = 0; int m = matrix.length, n = matrix[0].length; for (int i = 0; i < m; ++i) { int[] sum = new int[n]; for (int j = i; j < m; ++j) { for (int c = 0; c < n; ++c) { sum[c] += matrix[j][c]; } ans += subarraySum(sum, target); } } return ans; }
public int totalHammingDistance(int[] nums) { int ans = 0, n = nums.length; for (int i = 0; i < 30; ++i) { int c = 0; for (int val : nums) { c += (val >> i) & 1; } ans += c * (n - c); } return ans; }
public int hammingDistance(int x, int y) { return Integer.bitCount(x ^ y); }
public boolean isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }
public String reverseParentheses(String s) { Deque<String> stack = new LinkedList<String>(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == '(') { stack.push(sb.toString()); sb.setLength(0); } else if (ch == ')') { sb.reverse(); sb.insert(0, stack.pop()); } else { sb.append(ch); } } return sb.toString(); }
public int strangePrinter(String s) { int n = s.length(); int[][] f = new int[n][n]; for (int i = n - 1; i >= 0; i--) { f[i][i] = 1; for (int j = i + 1; j < n; j++) { if (s.charAt(i) == s.charAt(j)) { f[i][j] = f[i][j - 1]; } else { int minn = Integer.MAX_VALUE; for (int k = i; k < j; k++) { minn = Math.min(minn, f[i][k] + f[k + 1][j]); } f[i][j] = minn; } } } return f[0][n - 1]; }
public boolean xorGame(int[] nums) { if (nums.length % 2 == 0) { return true; } int xor = 0; for (int num : nums) { xor ^= num; } return xor == 0; }
public int maxUncrossedLines(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { int num1 = nums1[i - 1]; for (int j = 1; j <= n; j++) { int num2 = nums2[j - 1]; if (num1 == num2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; }
public int kthLargestValue(int[][] matrix, int k) { int m = matrix.length, n = matrix[0].length; int[][] pre = new int[m + 1][n + 1]; List<Integer> results = new ArrayList<Integer>(); for (int i = 1; i <= m; ++i) { for (int j = 1; j <= n; ++j) { pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1]; results.add(pre[i][j]); } } Collections.sort(results, new Comparator<Integer>() { public int compare(Integer num1, Integer num2) { return num2 - num1; } }); return results.get(k - 1); }
public int findMaximumXOR(int[] nums) { int x = 0; for (int k = HIGH_BIT; k >= 0; --k) { Set<Integer> seen = new HashSet<Integer>(); for (int num : nums) { seen.add(num >> k); } int xNext = x * 2 + 1; boolean found = false; for (int num : nums) { if (seen.contains(xNext ^ (num >> k))) { found = true; break; } } if (found) { x = xNext; } else { x = xNext - 1; } } return x; }
public int romanToInt(String s) { int ans = 0; int n = s.length(); for (int i = 0; i < n; ++i) { int value = symbolValues.get(s.charAt(i)); if (i < n - 1 && value < symbolValues.get(s.charAt(i + 1))) { ans -= value; } else { ans += value; } } return ans; }
public String intToRoman(int num) { StringBuffer roman = new StringBuffer(); for (int i = 0; i < values.length; ++i) { int value = values[i]; String symbol = symbols[i]; while (num >= value) { num -= value; roman.append(symbol); } if (num == 0) { break; } } return roman.toString(); }
public int[] decode(int[] encoded) { int n = encoded.length + 1; int total = 0; for (int i = 1; i <= n; i++) { total ^= i; } int odd = 0; for (int i = 1; i < n - 1; i += 2) { odd ^= encoded[i]; } int[] perm = new int[n]; perm[0] = total ^ odd; for (int i = 0; i < n - 1; i++) { perm[i + 1] = perm[i] ^ encoded[i]; } return perm; }
public int[] decode(int[] encoded, int first) { int n = encoded.length + 1; int[] arr = new int[n]; arr[0] = first; for (int i = 1; i < n; i++) { arr[i] = arr[i - 1] ^ encoded[i - 1]; } return arr; }
public int rob(int[] nums) { int size = nums.length; int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i < size; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; }
public int reverse(int x) { int rev = 0; while (x != 0) { if (rev < Integer.MIN_VALUE / 10 || rev > Integer.MAX_VALUE / 10) { return 0; } int digit = x % 10; x /= 10; rev = rev * 10 + digit; } return rev; }
public int maximumElementAfterDecrementingAndRearranging(int[] arr) { int n = arr.length; Arrays.sort(arr); arr[0] = 1; for (int i = 1; i < n; ++i) { arr[i] = Math.min(arr[i], arr[i - 1] + 1); } return arr[n - 1]; }
public boolean judgeSquareSum(int c) { for (long a = 0; a * a <= c; a++) { double b = Math.sqrt(c - a * a); if (b == (int) b) { return true; } } return false; }
public boolean canCross(int[] stones) { int n = stones.length; boolean[][] dp = new boolean[n][n]; dp[0][0] = true; for (int i = 1; i < n; ++i) { if (stones[i] - stones[i - 1] > i) { return false; } } for (int i = 1; i < n; ++i) { for (int j = i - 1; j >= 0; --j) { int k = stones[i] - stones[j]; if (k > j + 1) { break; } dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; if (i == n - 1 && dp[i][k]) { return true; } } } return false; }
public int singleNumber(int[] nums) { int ans = 0; for (int i = 0; i < 32; ++i) { int total = 0; for (int num: nums) { total += ((num >> i) & 1); } if (total % 3 != 0) { ans |= (1 << i); } } return ans; }
public int rangeSumBST(TreeNode root, int low, int high) { if (root == null) { return 0; } if (root.val > high) { return rangeSumBST(root.left, low, high); } if (root.val < low) { return rangeSumBST(root.right, low, high); } return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high); }
public int maxFrequency(int[] nums, int k) { Arrays.sort(nums); int n = nums.length; long total = 0; int l = 0, res = 1; for (int r = 1; r < n; ++r) { total += (long) (nums[r] - nums[r - 1]) * (r - l); while (total > k) { total -= nums[r] - nums[l]; ++l; } res = Math.max(res, r - l + 1); } return res; }
public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i <= target; i++) { for (int num : nums) { if (num <= i) { dp[i] += dp[i - num]; } } } return dp[target]; }
public int numDecodings(String s) { int n = s.length(); int[] f = new int[n + 1]; f[0] = 1; for (int i = 1; i <= n; ++i) { if (s.charAt(i - 1) != '0') { f[i] += f[i - 1]; } if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) { f[i] += f[i - 2]; } } return f[n]; }
public int strStr(String haystack, String needle) { int n = haystack.length(), m = needle.length(); for (int i = 0; i + m <= n; i++) { boolean flag = true; for (int j = 0; j < m; j++) { if (haystack.charAt(i + j) != needle.charAt(j)) { flag = false; break; } } if (flag) { return i; } } return -1; }
public int removeElement(int[] nums, int val) { int n = nums.length; int left = 0; for (int right = 0; right < n; right++) { if (nums[right] != val) { nums[left] = nums[right]; left++; } } return left; }
public int removeDuplicates(int[] nums) { int n = nums.length; if (n == 0) { return 0; } int fast = 1, slow = 1; while (fast < n) { if (nums[fast] != nums[fast - 1]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { int n = nums.length; Map<Long, Long> map = new HashMap<Long, Long>(); long w = (long) t + 1; for (int i = 0; i < n; i++) { long id = getID(nums[i], w); if (map.containsKey(id)) { return true; } if (map.containsKey(id - 1) && Math.abs(nums[i] - map.get(id - 1)) < w) { return true; } if (map.containsKey(id + 1) && Math.abs(nums[i] - map.get(id + 1)) < w) { return true; } map.put(id, (long) nums[i]); if (i >= k) { map.remove(getID(nums[i - k], w)); } } return false; }
public int rob(int[] nums) { int length = nums.length; if (length == 1) { return nums[0]; } else if (length == 2) { return Math.max(nums[0], nums[1]); } return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); }
public boolean isUgly(int n) { if (n <= 0) { return false; } int[] factors = {2, 3, 5}; for (int factor : factors) { while (n % factor == 0) { n /= factor; } } return n == 1; }
public int nthUglyNumber(int n) { int[] dp = new int[n + 1]; dp[1] = 1; int p2 = 1, p3 = 1, p5 = 1; for (int i = 2; i <= n; i++) { int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5; dp[i] = Math.min(Math.min(num2, num3), num5); if (dp[i] == num2) { p2++; } if (dp[i] == num3) { p3++; } if (dp[i] == num5) { p5++; } } return dp[n]; }
public boolean search(int[] nums, int target) { int n = nums.length; if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l <= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } if (nums[l] == nums[mid] && nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] <= nums[mid]) { if (nums[l] <= target && target < nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] < target && target <= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; }
public int removeDuplicates(int[] nums) { int n = nums.length; if (n <= 2) { return n; } int slow = 2, fast = 2; while (fast < n) { if (nums[slow - 2] != nums[fast]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; }
public int findMin(int[] nums) { int low = 0; int high = nums.length - 1; while (low < high) { int pivot = low + (high - low) / 2; if (nums[pivot] < nums[high]) { high = pivot; } else { low = pivot + 1; } } return nums[low]; }
public int numRabbits(int[] answers) { Map<Integer, Integer> count = new HashMap<Integer, Integer>(); for (int y : answers) { count.put(y, count.getOrDefault(y, 0) + 1); } int ans = 0; for (Map.Entry<Integer, Integer> entry : count.entrySet()) { int y = entry.getKey(), x = entry.getValue(); ans += (x + y) / (y + 1) * (y + 1); } return ans; }
public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { char c1 = text1.charAt(i - 1); for (int j = 1; j <= n; j++) { char c2 = text2.charAt(j - 1); if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; }
public int trap(int[] height) { int ans = 0; Deque<Integer> stack = new LinkedList<Integer>(); int n = height.length; for (int i = 0; i < n; ++i) { while (!stack.isEmpty() && height[i] > height[stack.peek()]) { int top = stack.pop(); if (stack.isEmpty()) { break; } int left = stack.peek(); int currWidth = i - left - 1; int currHeight = Math.min(height[left], height[i]) - height[top]; ans += currWidth * currHeight; } stack.push(i); } return ans; }
public int reverseBits(int n) { int rev = 0; for (int i = 0; i < 32 && n != 0; ++i) { rev |= (n & 1) << (31 - i); n >>>= 1; } return rev; }
public ListNode rotateRight(ListNode head, int k) { if (k == 0 || head == null || head.next == null) { return head; } int n = 1; ListNode iter = head; while (iter.next != null) { iter = iter.next; n++; } int add = n - k % n; if (add == n) { return head; } iter.next = head; while (add-- > 0) { iter = iter.next; } ListNode ret = iter.next; iter.next = null; return ret; }
public ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; }
public ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode dummy = new ListNode(0, head); ListNode cur = dummy; while (cur.next != null && cur.next.next != null) { if (cur.next.val == cur.next.next.val) { int x = cur.next.val; while (cur.next != null && cur.next.val == x) { cur.next = cur.next.next; } } else { cur = cur.next; } } return dummy.next; }
public boolean find132pattern(int[] nums) { int n = nums.length; Deque<Integer> candidateK = new LinkedList<Integer>(); candidateK.push(nums[n - 1]); int maxK = Integer.MIN_VALUE; for (int i = n - 2; i >= 0; --i) { if (nums[i] < maxK) { return true; } while (!candidateK.isEmpty() && nums[i] > candidateK.peek()) { maxK = candidateK.pop(); } if (nums[i] > maxK) { candidateK.push(nums[i]); } } return false; }
public int hammingWeight(int n) { int ret = 0; for (int i = 0; i < 32; i++) { if ((n & (1 << i)) != 0) { ret++; } } return ret; }
public void setZeroes(int[][] matrix) { int m = matrix.length, n = matrix[0].length; boolean[] row = new boolean[m]; boolean[] col = new boolean[n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == 0) { row[i] = col[j] = true; } } } for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (row[i] || col[j]) { matrix[i][j] = 0; } } } }
public int evalRPN(String[] tokens) { Deque<Integer> stack = new LinkedList<Integer>(); int n = tokens.length; for (int i = 0; i < n; i++) { String token = tokens[i]; if (isNumber(token)) { stack.push(Integer.parseInt(token)); } else { int num2 = stack.pop(); int num1 = stack.pop(); switch (token) { case "+": stack.push(num1 + num2); break; case "-": stack.push(num1 - num2); break; case "*": stack.push(num1 * num2); break; case "/": stack.push(num1 / num2); break; default: } } } return stack.pop(); }
public void merge(int[] nums1, int m, int[] nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 >= 0 || p2 >= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] > nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }
public double nthPersonGetsNthSeat(int n) { return n == 1 ? 1.0 : 0.5; }
public int numDistinct(String s, String t) { int m = s.length(), n = t.length(); if (m < n) { return 0; } int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i <= m; i++) { dp[i][n] = 1; } for (int i = m - 1; i >= 0; i--) { char sChar = s.charAt(i); for (int j = n - 1; j >= 0; j--) { char tChar = t.charAt(j); if (sChar == tChar) { dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]; } else { dp[i][j] = dp[i + 1][j]; } } } return dp[0][0]; }
public int[][] generateMatrix(int n) { int num = 1; int[][] matrix = new int[n][n]; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left <= right && top <= bottom) { for (int column = left; column <= right; column++) { matrix[top][column] = num; num++; } for (int row = top + 1; row <= bottom; row++) { matrix[row][right] = num; num++; } if (left < right && top < bottom) { for (int column = right - 1; column > left; column--) { matrix[bottom][column] = num; num++; } for (int row = bottom; row > top; row--) { matrix[row][left] = num; num++; } } left++; right--; top++; bottom--; } return matrix; }
public boolean isValidSerialization(String preorder) { int n = preorder.length(); int i = 0; int slots = 1; while (i < n) { if (slots == 0) { return false; } if (preorder.charAt(i) == ',') { i++; } else if (preorder.charAt(i) == '#'){ slots--; i++; } else { while (i < n && preorder.charAt(i) != ',') { i++; } slots++; } } return slots == 0; }
public int calculate(String s) { Deque<Integer> stack = new LinkedList<Integer>(); char preSign = '+'; int num = 0; int n = s.length(); for (int i = 0; i < n; ++i) { if (Character.isDigit(s.charAt(i))) { num = num * 10 + s.charAt(i) - '0'; } if (!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ' || i == n - 1) { switch (preSign) { case '+': stack.push(num); break; case '-': stack.push(-num); break; case '*': stack.push(stack.pop() * num); break; default: stack.push(stack.pop() / num); } preSign = s.charAt(i); num = 0; } } int ans = 0; while (!stack.isEmpty()) { ans += stack.pop(); } return ans; }
public String removeDuplicates(String s) { StringBuffer stack = new StringBuffer(); int top = -1; for (int i = 0; i < s.length(); ++i) { char ch = s.charAt(i); if (top >= 0 && stack.charAt(top) == ch) { stack.deleteCharAt(top); --top; } else { stack.append(ch); ++top; } } return stack.toString(); }
public int minCut(String s) { int n = s.length(); boolean[][] g = new boolean[n][n]; for (int i = 0; i < n; ++i) { Arrays.fill(g[i], true); } for (int i = n - 1; i >= 0; --i) { for (int j = i + 1; j < n; ++j) { g[i][j] = s.charAt(i) == s.charAt(j) && g[i + 1][j - 1]; } } int[] f = new int[n]; Arrays.fill(f, Integer.MAX_VALUE); for (int i = 0; i < n; ++i) { if (g[0][i]) { f[i] = 0; } else { for (int j = 0; j < i; ++j) { if (g[j + 1][i]) { f[i] = Math.min(f[i], f[j] + 1); } } } } return f[n - 1]; }
public int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] ret = new int[n]; Arrays.fill(ret, -1); Deque<Integer> stack = new LinkedList<Integer>(); for (int i = 0; i < n * 2 - 1; i++) { while (!stack.isEmpty() && nums[stack.peek()] < nums[i % n]) { ret[stack.pop()] = nums[i % n]; } stack.push(i % n); } return ret; }
public ListNode reverseBetween(ListNode head, int left, int right) { ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; for (int i = 0; i < left - 1; i++) { pre = pre.next; } ListNode cur = pre.next; ListNode next; for (int i = 0; i < right - left; i++) { next = cur.next; cur.next = next.next; next.next = pre.next; pre.next = next; } return dummyNode.next; }
public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator<int[]>() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0]; } else { return e2[1] - e1[1]; } } }); int[] f = new int[n]; Arrays.fill(f, 1); int ans = 1; for (int i = 1; i < n; ++i) { for (int j = 0; j < i; ++j) { if (envelopes[j][1] < envelopes[i][1]) { f[i] = Math.max(f[i], f[j] + 1); } } ans = Math.max(ans, f[i]); } return ans; }
public int[] countBits(int n) { int[] bits = new int[n + 1]; int highBit = 0; for (int i = 1; i <= n; i++) { if ((i & (i - 1)) == 0) { highBit = i; } bits[i] = bits[i - highBit] + 1; } return bits; }
public int longestSubstring(String s, int k) { int ret = 0; int n = s.length(); for (int t = 1; t <= 26; t++) { int l = 0, r = 0; int[] cnt = new int[26]; int tot = 0; int less = 0; while (r < n) { cnt[s.charAt(r) - 'a']++; if (cnt[s.charAt(r) - 'a'] == 1) { tot++; less++; } if (cnt[s.charAt(r) - 'a'] == k) { less--; } while (tot > t) { cnt[s.charAt(l) - 'a']--; if (cnt[s.charAt(l) - 'a'] == k - 1) { less++; } if (cnt[s.charAt(l) - 'a'] == 0) { tot--; less--; } l++; } if (less == 0) { ret = Math.max(ret, r - l + 1); } r++; } } return ret; }
public int[][] flipAndInvertImage(int[][] image) { int n = image.length; for (int i = 0; i < n; i++) { int left = 0, right = n - 1; while (left < right) { if (image[i][left] == image[i][right]) { image[i][left] ^= 1; image[i][right] ^= 1; } left++; right--; } if (left == right) { image[i][left] ^= 1; } } return image; }
public int maxSatisfied(int[] customers, int[] grumpy, int minutes) { int total = 0; int n = customers.length; for (int i = 0; i < n; i++) { if (grumpy[i] == 0) { total += customers[i]; } } int increase = 0; for (int i = 0; i < minutes; i++) { increase += customers[i] * grumpy[i]; } int maxIncrease = increase; for (int i = minutes; i < n; i++) { increase = increase - customers[i - minutes] * grumpy[i - minutes] + customers[i] * grumpy[i]; maxIncrease = Math.max(maxIncrease, increase); } return total + maxIncrease; }
public boolean isToeplitzMatrix(int[][] matrix) { int m = matrix.length, n = matrix[0].length; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { if (matrix[i][j] != matrix[i - 1][j - 1]) { return false; } } } return true; }
public int findShortestSubArray(int[] nums) { Map<Integer, int[]> map = new HashMap<Integer, int[]>(); int n = nums.length; for (int i = 0; i < n; i++) { if (map.containsKey(nums[i])) { map.get(nums[i])[0]++; map.get(nums[i])[2] = i; } else { map.put(nums[i], new int[]{1, i, i}); } } int maxNum = 0, minLen = 0; for (Map.Entry<Integer, int[]> entry : map.entrySet()) { int[] arr = entry.getValue(); if (maxNum < arr[0]) { maxNum = arr[0]; minLen = arr[2] - arr[1] + 1; } else if (maxNum == arr[0]) { if (minLen > arr[2] - arr[1] + 1) { minLen = arr[2] - arr[1] + 1; } } } return minLen; }
public int longestOnes(int[] nums, int k) { int n = nums.length; int[] P = new int[n + 1]; for (int i = 1; i <= n; ++i) { P[i] = P[i - 1] + (1 - nums[i - 1]); } int ans = 0; for (int right = 0; right < n; ++right) { int left = binarySearch(P, P[right + 1] - k); ans = Math.max(ans, right - left + 1); } return ans; }
public int minKBitFlips(int[] nums, int k) { int n = nums.length; int[] diff = new int[n + 1]; int ans = 0, revCnt = 0; for (int i = 0; i < n; ++i) { revCnt ^= diff[i]; if (nums[i] == revCnt) { if (i + k > n) { return -1; } ++ans; revCnt ^= 1; diff[i + k] ^= 1; } } return ans; }
public int[][] matrixReshape(int[][] nums, int r, int c) { int m = nums.length; int n = nums[0].length; if (m * n != r * c) { return nums; } int[][] ans = new int[r][c]; for (int x = 0; x < m * n; ++x) { ans[x / c][x % c] = nums[x / n][x % n]; } return ans; }
public int arrayPairSum(int[] nums) { Arrays.sort(nums); int ans = 0; for (int i = 0; i < nums.length; i += 2) { ans += nums[i]; } return ans; }
public int findMaxConsecutiveOnes(int[] nums) { int maxCount = 0, count = 0; int n = nums.length; for (int i = 0; i < n; i++) { if (nums[i] == 1) { count++; } else { maxCount = Math.max(maxCount, count); count = 0; } } maxCount = Math.max(maxCount, count); return maxCount; }
public List<Integer> findDisappearedNumbers(int[] nums) { int n = nums.length; for (int num : nums) { int x = (num - 1) % n; nums[x] += n; } List<Integer> ret = new ArrayList<Integer>(); for (int i = 0; i < n; i++) { if (nums[i] <= n) { ret.add(i + 1); } } return ret; }
public List<Integer> getRow(int rowIndex) { List<Integer> pre = new ArrayList<Integer>(); for (int i = 0; i <= rowIndex; ++i) { List<Integer> cur = new ArrayList<Integer>(); for (int j = 0; j <= i; ++j) { if (j == 0 || j == i) { cur.add(1); } else { cur.add(pre.get(j - 1) + pre.get(j)); } } pre = cur; } return pre; }
public boolean checkInclusion(String s1, String s2) { int n = s1.length(), m = s2.length(); if (n > m) { return false; } int[] cnt1 = new int[26]; int[] cnt2 = new int[26]; for (int i = 0; i < n; ++i) { ++cnt1[s1.charAt(i) - 'a']; ++cnt2[s2.charAt(i) - 'a']; } if (Arrays.equals(cnt1, cnt2)) { return true; } for (int i = n; i < m; ++i) { ++cnt2[s2.charAt(i) - 'a']; --cnt2[s2.charAt(i - n) - 'a']; if (Arrays.equals(cnt1, cnt2)) { return true; } } return false; }
public int subarraysWithKDistinct(int[] nums, int k) { int n = nums.length; int[] num1 = new int[n + 1]; int[] num2 = new int[n + 1]; int tot1 = 0, tot2 = 0; int left1 = 0, left2 = 0, right = 0; int ret = 0; while (right < n) { if (num1[nums[right]] == 0) { tot1++; } num1[nums[right]]++; if (num2[nums[right]] == 0) { tot2++; } num2[nums[right]]++; while (tot1 > k) { num1[nums[left1]]--; if (num1[nums[left1]] == 0) { tot1--; } left1++; } while (tot2 > k - 1) { num2[nums[left2]]--; if (num2[nums[left2]] == 0) { tot2--; } left2++; } ret += left2 - left1; right++; } return ret; }
public int maxTurbulenceSize(int[] arr) { int n = arr.length; int ret = 1; int left = 0, right = 0; while (right < n - 1) { if (left == right) { if (arr[left] == arr[left + 1]) { left++; } right++; } else { if (arr[right - 1] < arr[right] && arr[right] > arr[right + 1]) { right++; } else if (arr[right - 1] > arr[right] && arr[right] < arr[right + 1]) { right++; } else { left = right; } } ret = Math.max(ret, right - left + 1); } return ret; }
public boolean checkPossibility(int[] nums) { int n = nums.length; for (int i = 0; i < n - 1; ++i) { int x = nums[i], y = nums[i + 1]; if (x > y) { nums[i] = y; if (isSorted(nums)) { return true; } nums[i] = x; nums[i + 1] = x; return isSorted(nums); } } return true; }
public int equalSubstring(String s, String t, int maxCost) { int n = s.length(); int[] accDiff = new int[n + 1]; for (int i = 0; i < n; i++) { accDiff[i + 1] = accDiff[i] + Math.abs(s.charAt(i) - t.charAt(i)); } int maxLength = 0; for (int i = 1; i <= n; i++) { int start = binarySearch(accDiff, i, accDiff[i] - maxCost); maxLength = Math.max(maxLength, i - start); } return maxLength; }
public double findMaxAverage(int[] nums, int k) { int sum = 0; int n = nums.length; for (int i = 0; i < k; i++) { sum += nums[i]; } int maxSum = sum; for (int i = k; i < n; i++) { sum = sum - nums[i - k] + nums[i]; maxSum = Math.max(maxSum, sum); } return 1.0 * maxSum / k; }
public int[] singleNumber(int[] nums) { int xorsum = 0; for (int num : nums) { xorsum ^= num; } int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum)); int type1 = 0, type2 = 0; for (int num : nums) { if ((num & lsb) != 0) { type1 ^= num; } else { type2 ^= num; } } return new int[]{type1, type2}; }
public int characterReplacement(String s, int k) { int[] num = new int[26]; int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right < n) { num[s.charAt(right) - 'A']++; maxn = Math.max(maxn, num[s.charAt(right) - 'A']); if (right - left + 1 - maxn > k) { num[s.charAt(left) - 'A']--; left++; } right++; } return right - left; }
public int countTriplets(int[] arr) { int n = arr.length; int[] s = new int[n + 1]; for (int i = 0; i < n; ++i) { s[i + 1] = s[i] ^ arr[i]; } int ans = 0; for (int i = 0; i < n; ++i) { for (int j = i + 1; j < n; ++j) { for (int k = j; k < n; ++k) { if (s[i] == s[k + 1]) { ++ans; } } } } return ans; }
public int pivotIndex(int[] nums) { int total = Arrays.stream(nums).sum(); int sum = 0; for (int i = 0; i < nums.length; ++i) { if (2 * sum + nums[i] == total) { return i; } sum += nums[i]; } return -1; }
public int findLengthOfLCIS(int[] nums) { int ans = 0; int n = nums.length; int start = 0; for (int i = 0; i < n; i++) { if (i > 0 && nums[i] <= nums[i - 1]) { start = i; } ans = Math.max(ans, i - start + 1); } return ans; }
public List<Integer> addToArrayForm(int[] num, int k) { List<Integer> res = new ArrayList<Integer>(); int n = num.length; for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) { if (i >= 0) { k += num[i]; } res.add(k % 10); } Collections.reverse(res); return res; }
public int maximumProduct(int[] nums) { Arrays.sort(nums); int n = nums.length; return Math.max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]); }
public boolean checkStraightLine(int[][] coordinates) { int deltaX = coordinates[0][0], deltaY = coordinates[0][1]; int n = coordinates.length; for (int i = 0; i < n; i++) { coordinates[i][0] -= deltaX; coordinates[i][1] -= deltaY; } int A = coordinates[1][1], B = -coordinates[1][0]; for (int i = 2; i < n; i++) { int x = coordinates[i][0], y = coordinates[i][1]; if (A * x + B * y != 0) { return false; } } return true; }
public List<Boolean> prefixesDivBy5(int[] nums) { List<Boolean> answer = new ArrayList<Boolean>(); int prefix = 0; int length = nums.length; for (int i = 0; i < length; i++) { prefix = ((prefix << 1) + nums[i]) % 5; answer.add(prefix == 0); } return answer; }
public int maxProfit(int[] prices) { int n = prices.length; int buy1 = -prices[0], sell1 = 0; int buy2 = -prices[0], sell2 = 0; for (int i = 1; i < n; ++i) { buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]); } return sell2; }
public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; }
public void rotate(int[] nums, int k) { int n = nums.length; int[] newArr = new int[n]; for (int i = 0; i < n; ++i) { newArr[(i + k) % n] = nums[i]; } System.arraycopy(newArr, 0, nums, 0, n); }
public List<List<Integer>> largeGroupPositions(String s) { List<List<Integer>> ret = new ArrayList<List<Integer>>(); int n = s.length(); int num = 1; for (int i = 0; i < n; i++) { if (i == n - 1 || s.charAt(i) != s.charAt(i + 1)) { if (num >= 3) { ret.add(Arrays.asList(i - num + 1, i)); } num = 1; } else { num++; } } return ret; }
public int fib(int n) { if (n < 2) { return n; } int p = 0, q = 0, r = 1; for (int i = 2; i <= n; ++i) { p = q; q = r; r = p + q; } return r; }
public ListNode partition(ListNode head, int x) { ListNode small = new ListNode(0); ListNode smallHead = small; ListNode large = new ListNode(0); ListNode largeHead = large; while (head != null) { if (head.val < x) { small.next = head; small = small.next; } else { large.next = head; large = large.next; } head = head.next; } large.next = null; small.next = largeHead.next; return smallHead.next; }
public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; int[] prefixMax = new int[n]; int[] suffixMax = new int[n]; for (int i = 0; i < n; ++i) { if (i % k == 0) { prefixMax[i] = nums[i]; } else { prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]); } } for (int i = n - 1; i >= 0; --i) { if (i == n - 1 || (i + 1) % k == 0) { suffixMax[i] = nums[i]; } else { suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]); } } int[] ans = new int[n - k + 1]; for (int i = 0; i <= n - k; ++i) { ans[i] = Math.max(suffixMax[i], prefixMax[i + k - 1]); } return ans; }
public boolean canPlaceFlowers(int[] flowerbed, int n) { int count = 0; int m = flowerbed.length; int prev = -1; for (int i = 0; i < m; i++) { if (flowerbed[i] == 1) { if (prev < 0) { count += i / 2; } else { count += (i - prev - 2) / 2; } prev = i; } } if (prev < 0) { count += (m + 1) / 2; } else { count += (m - prev - 1) / 2; } return count >= n; }
public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length == 0) { return 0; } Arrays.sort(intervals, new Comparator<int[]>() { public int compare(int[] interval1, int[] interval2) { return interval1[1] - interval2[1]; } }); int n = intervals.length; int right = intervals[0][1]; int ans = 1; for (int i = 1; i < n; ++i) { if (intervals[i][0] >= right) { ++ans; right = intervals[i][1]; } } return n - ans; }
public int lastStoneWeight(int[] stones) { PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() > 1) { int a = pq.poll(); int b = pq.poll(); if (a > b) { pq.offer(a - b); } } return pq.isEmpty() ? 0 : pq.poll(); }
public int minPatches(int[] nums, int n) { int patches = 0; long x = 1; int length = nums.length, index = 0; while (x <= n) { if (index < length && nums[index] <= x) { x += nums[index]; index++; } else { x *= 2; patches++; } } return patches; }
public boolean isIsomorphic(String s, String t) { Map<Character, Character> s2t = new HashMap<Character, Character>(); Map<Character, Character> t2s = new HashMap<Character, Character>(); int len = s.length(); for (int i = 0; i < len; ++i) { char x = s.charAt(i), y = t.charAt(i); if ((s2t.containsKey(x) && s2t.get(x) != y) || (t2s.containsKey(y) && t2s.get(y) != x)) { return false; } s2t.put(x, y); t2s.put(y, x); } return true; }
public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int numOfChildren = g.length, numOfCookies = s.length; int count = 0; for (int i = 0, j = 0; i < numOfChildren && j < numOfCookies; i++, j++) { while (j < numOfCookies && g[i] > s[j]) { j++; } if (j < numOfCookies) { count++; } } return count; }
public int candy(int[] ratings) { int n = ratings.length; int[] left = new int[n]; for (int i = 0; i < n; i++) { if (i > 0 && ratings[i] > ratings[i - 1]) { left[i] = left[i - 1] + 1; } else { left[i] = 1; } } int right = 0, ret = 0; for (int i = n - 1; i >= 0; i--) { if (i < n - 1 && ratings[i] > ratings[i + 1]) { right++; } else { right = 1; } ret += Math.max(left[i], right); } return ret; }
public int firstUniqChar(String s) { Map<Character, Integer> frequency = new HashMap<Character, Integer>(); for (int i = 0; i < s.length(); ++i) { char ch = s.charAt(i); frequency.put(ch, frequency.getOrDefault(ch, 0) + 1); } for (int i = 0; i < s.length(); ++i) { if (frequency.get(s.charAt(i)) == 1) { return i; } } return -1; }
public int minCostClimbingStairs(int[] cost) { int n = cost.length; int[] dp = new int[n + 1]; dp[0] = dp[1] = 0; for (int i = 2; i <= n; i++) { dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[n]; }
public void rotate(int[][] matrix) { int n = matrix.length; int[][] matrix_new = new int[n][n]; for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { matrix_new[j][n - i - 1] = matrix[i][j]; } } for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { matrix[i][j] = matrix_new[i][j]; } } }
public char findTheDifference(String s, String t) { int[] cnt = new int[26]; for (int i = 0; i < s.length(); ++i) { char ch = s.charAt(i); cnt[ch - 'a']++; } for (int i = 0; i < t.length(); ++i) { char ch = t.charAt(i); cnt[ch - 'a']--; if (cnt[ch - 'a'] < 0) { return ch; } } return ' '; }
public int maxProfit(int[] prices, int fee) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i < n; ++i) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; }
public int monotoneIncreasingDigits(int n) { char[] strN = Integer.toString(n).toCharArray(); int i = 1; while (i < strN.length && strN[i - 1] <= strN[i]) { i += 1; } if (i < strN.length) { while (i > 0 && strN[i - 1] > strN[i]) { strN[i - 1] -= 1; i -= 1; } for (i += 1; i < strN.length; ++i) { strN[i] = '9'; } } return Integer.parseInt(new String(strN)); }
public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); int n = nums.length; for (int i = 0; i < n - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; }
public int wiggleMaxLength(int[] nums) { int n = nums.length; if (n < 2) { return n; } int[] up = new int[n]; int[] down = new int[n]; up[0] = down[0] = 1; for (int i = 1; i < n; i++) { if (nums[i] > nums[i - 1]) { up[i] = Math.max(up[i - 1], down[i - 1] + 1); down[i] = down[i - 1]; } else if (nums[i] < nums[i - 1]) { up[i] = up[i - 1]; down[i] = Math.max(up[i - 1] + 1, down[i - 1]); } else { up[i] = up[i - 1]; down[i] = down[i - 1]; } } return Math.max(up[n - 1], down[n - 1]); }
public String predictPartyVictory(String senate) { int n = senate.length(); Queue<Integer> radiant = new LinkedList<Integer>(); Queue<Integer> dire = new LinkedList<Integer>(); for (int i = 0; i < n; ++i) { if (senate.charAt(i) == 'R') { radiant.offer(i); } else { dire.offer(i); } } while (!radiant.isEmpty() && !dire.isEmpty()) { int radiantIndex = radiant.poll(), direIndex = dire.poll(); if (radiantIndex < direIndex) { radiant.offer(radiantIndex + n); } else { dire.offer(direIndex + n); } } return !radiant.isEmpty() ? "Radiant" : "Dire"; }
public boolean lemonadeChange(int[] bills) { int five = 0, ten = 0; for (int bill : bills) { if (bill == 5) { five++; } else if (bill == 10) { if (five == 0) { return false; } five--; ten++; } else { if (five > 0 && ten > 0) { five--; ten--; } else if (five >= 3) { five -= 3; } else { return false; } } } return true; }
